Sphere 2.0 API Reference
========================

minisphere uses JavaScript for game logic.  This is the same programming
language used by the original Sphere engine, which minisphere is the successor
to.  In fact, minisphere implements most of the Sphere 1.5 API, with several
backwards-compatible enhancements.

This file documents the functions exposed by minisphere for use in game scripts.
The list may not be exhaustive; refer to the Sphere 1.x API reference for a full
list of legacy functions (a few of those may not be supported, however).

    Sphere 1.x API Reference:
    https://github.com/sphere-group/sphere/blob/master/sphere/docs/development/api.txt


Engine Identification
---------------------

The functions below can be used to determine, at a broad level, the
engine's level of support for various features.

GetVersion()

    Returns the Sphere API version level as a floating point number. When called
    under this version of minisphere, this function returns 2.0, indicating
    version 2 of the Sphere API.

GetVersionString()

    Returns the engine's version identification string. The string returned will
    be in the following format:

        v2.0 (minisphere 3.1a0)

GetExtensions()

    Returns an array of strings representing the engine's built-in capabilities.
    minisphere currently supports the following extensions (most of these should
    be self-explanatory):

        sphere-legacy-api
        sphere-obj-constructors
        sphere-obj-props
        sphere-async-api
        sphere-audialis
        sphere-coffeescript
        sphere-commonjs
        sphere-file-streams
        sphere-frameskip-api
        sphere-galileo
        sphere-galileo-shaders
        sphere-map-engine
        sphere-new-sockets
        sphere-rng-object
        sphere-s2gm
        sphere-spherefs
        sphere-typescript


S2GM Manifest Format
--------------------

A game targeting Sphere 2.0 may opt to use the S2GM format for its metadata
instead of--or in addition to--the legacy game.sgm format.  game.s2gm file is
simply a JSON file and looks like this:

    {
        "name": "Spectacles: Bruce's Story",
        "author": "Fat Cerberus",
        "summary": "Follow Scott Starcross in his quest to stop the Primus.",
        "resolution": "320x240",
        "script": "scripts/main.js",

        "minimumPlatform": {
            "recommend": "minisphere 3.0 or later",
            "apiVersion": 2.0,
            "extensions": [
                "sphere-legacy-api",
                "sphere-obj-constructors",
                "sphere-obj-props",
                "sphere-map-engine",
                "sphere-rng-object",
                "sphere-s2gm",
                "sphere-spherefs"
            ]
        }
    }

An important note on `apiVersion`: This refers to the Sphere API level, NOT the
engine version.  minisphere currently supports Sphere API version 2.0.

minimumPlatform, if present, is checked by the engine on startup and, if the
declared requirements are not met, the game will fail to start.  Besides that,
an S2GM may contain any amount of data in any layout, which will then be
available to game code at any time by calling GetGameManifest().

When building a game using Cell, you can compile an S2GM manifest using the
s2gm() asset.  See the Cell API reference for more details.


SphereFS File System
--------------------

minisphere follows the SphereFS standard for file paths. When providing a
filename to a function or method, it will be treated as relative to a specific
directory by default, generally a subdirectory below the current game's
game.sgm. To get around this and load files from a different location, you can
use one of the following SphereFS prefixes:

    ~usr/: The current user's save data directory.  This may be used to store
           save files and other such data where the user can easily access it.
           Guaranteed to be writable on all systems.  As of minisphere 3.0, this
           maps to <documents>/Sphere 2.0/saveData.
    ~sgm/: The directory containing game.sgm.  For backwards compatibility, this
           may also be specified as ~/.  You should not assume this is writable.
    ~sys/: minisphere's "system" directory.  This contains assets included with
           the engine.  Not likely to be writable.

By way of example, the following will open the kevfile `eaty-pigs.conf` from the
user's save data directory:

    var file = new KevFile("~usr/eaty-pigs.conf");

Starting with minisphere 2.0, several APIs are marked as "SphereFS compliant".
For an API to be considered compliant, any method accepting a filename must
treat an unprefixed, relative path as being relative to either ~sgm/ or ~usr/.
Most legacy APIs are not SphereFS compliant and treat filenames as relative to a
subdirectory of ~sgm/.  These cannot be made compliant without breaking
compatibility with Sphere 1.x.


CommonJS
--------

In addition to the legacy dependency management functions described below,
minisphere supports CommonJS modules, and this is the preferred method for
managing dependencies.  The built-in require() function is provided for this
purpose.

require(module_id);

    Loads a CommonJS module and returns its export table.  `module_id` is an
    abstract path (a string) identifying the module to load, with the same
    semantics as in, e.g. Node.js.  If the module cannot be found, an error will
    be thrown.  minisphere will look for modules in the following locations:

        ~sgm/commonjs
        ~sys/commonjs

    If require() is called inside of a module and the ID provided is prefixed
    with either './' or '../', this specifies a path relative to the calling
    module.


Classic Dependency Management
-----------------------------

The functions described below are maintained for backwards compatibility with
games and scripts written for Sphere 1.x, but should be considered deprecated.
Any new code should make use of CommonJS instead (see above).

RequireScript(filename)
EvaluateScript(filename)

    Not SphereFS compliant: `filename` is relative to ~sgm/scripts.

    Evaluates the contents of `filename`, as if the code contained within were
    part of the script containing the call.  If you've ever worked in C or C++,
    this is a bit like including a header file.

    Note: RequireScript only executes a given script once, regardless of how
    many RequireScript() calls specifying it are encountered.  This is generally
    preferable to EvaluateScript(), which always executes the script.

RequireSystemScript(filename)
EvaluateSystemScript(filename)

    `filename` is relative to ~sys/scripts.  SphereFS prefixes are not allowed.

    Same as above, except the script is loaded from the engine's system
    directory.  These are used to import scripts included with the engine.


Basic Debugging
---------------

Since minisphere 1.6, full single-step debugging has been available through
Sphere Studio, and minisphere 3.0 introduced the SSJ command-line debugger.  The
functions below may still come in handy as a sort of "poor man's debugging",
however:

Abort(message[, stack_offset])

    Forces the engine to close, displaying a specified error message.  The error
    is normally reported to originate at the location of the Abort() call; you
    may pass an optional negative stack offset to blame it on a function earlier
    in the call chain.  For example, the following code will report an error at
    the point PassTheBuck() is called, instead of at the Abort() call:

        function PassTheBuck() {
            Abort("PassTheBuck() says: It's not my fault!", -1);
        }
        PassTheBuck();

Alert(message[, stack_offset])

    Similar to Abort(), except the message is displayed in a dialog box and the
    game continues running as normal afterwards.  Useful for examining variables
    at runtime when debugging.

Assert(condition, error_message[, stack_offset]);

    If `condition` evaluates to true, does nothing.  Otherwise the behavior
    depends on whether a debugger is attached.  Without a debugger attached, the
    error is ignored (except for logging it to the console).  If a debugger *is*
    attached, the user has the option to continue execution, ignoring the error,
    or trigger a breakpoint, allowing it to be debugged.

    As with Abort(), `stack_offset` determines which callstack frame the error
    is blamed on.

DebugPrint(value1, value2, ...);

    Prints the provided values in the debugger.  This function has no effect
    if a debugger is not attached, so it's useful for logging low-level
    debugging information.

Print(value1, value2, ...);

    Like DebugPrint(), but sends the output to the console as well.  This should
    be used for general logging which might be helpful when debugging offline.


Logging
-------

Logging is another useful debugging tool.  When trying to diagnose a stubborn
bug, it often helps to have a persistent summary of everything that happened
when the issue surfaced.  Of course, this requires some vigilance on the part of
the developer to emit enough log entries!

new Logger(filename)

    SphereFS compliant.

    Opens a file for logging and constructs an object you can use to access the
    log.  An error will be thrown if the file cannot be opened for writing.

Logger:beginBlock(name)

    Opens a block with the heading `name` and increases the indent level.
    Blocks can be nested and are useful to group related log entries.

Logger:endBlock()

    Closes the innermost block and decreases the indent level.

Logger:write(text)

    Logs a line with the specified `text` at the current indent level.


Timing Functions
----------------

These are used to measure elapsed time during gameplay and coordinate timed
events.

Delay(ms);

    Suspends game execution for `ms` milliseconds.  The engine will "spin down"
    during this time and relinquish its CPU cycles to other applications.

GetSeconds();

    Returns the amount of time in seconds, in floating point, since some
    arbitrary point in time.  Precision is guaranteed to be < 1Âµs.

GetTime();

    Returns the number of milliseconds elapsed since some arbitrary point in
    time (usually engine start, but this is not guaranteed).  If you need more
    precision, use GetSeconds() instead.


Execution Control and Game Management
-------------------------------------

Many of these are only useful for startup games, which serve as launchers to
allow the user to choose a game to play.  For a game to be visible to a startup
game, it should be stored in `<documents>/Sphere 2.0/games`, or alternatively
(for backwards compatibility) in `<enginedir>/games`.

GetGameManifest()

    Returns an object describing the currently running game.  The object is of
    the same form as those returned by GetGameList() (see below) and is
    constructed from the game manifest (game.sgm or game.s2gm).

GetGameList()

    Returns an array of objects, one for each Sphere game found on the system.
    Each object has at least the following properties, and may have more
    depending on the content of the game manifest:

        .name:        The game's title, taken from the game manifest.
        .directory:   The absolute path of the directory the game was found in.
                      For packaged games, this is the filename of the package
                      file instead of a directory name.
        .author:      The game's author, taken from the game manifest.
        .description: A short description of the game, taken from the game
                      manifest.

    GetGameList() searches for games in the following directories, in the order
    listed:

        <enginedir>/games/
        <documents>/Sphere 2.0/games/

Async(script);

    Queues a script or function to be executed on the next FlipScreen() call.
    This is similar to setTimeout(func, 0); in the browser.

DoEvents();

    Performs a single iteration of the engine's event loop.  DoEvents() can be
    used in place of FlipScreen() (which clears the backbuffer) in a long-
    running loop when you don't want to disturb the contents of the screen.

    DoEvents() always returns `true`, allowing you to use it as part of a loop
    condition:

        while (condition && DoEvents()) {
            // do stuff...
        }

ExecuteGame(directory)

    Not SphereFS compliant: SphereFS prefixes are not honored.

    Replaces the currently running game with the one found in the specified
    directory.  The directory is assumed to be relative to <enginedir>/games.

    Unlike most of the minisphere API, this function will accept an absolute
    path.

Exit()

    Exits the current game and shuts down the engine.  If the current game was
    started by via ExecuteGame(), the original game will be restarted following
    the Exit() call.

RestartGame()

    Restarts the current game.  All game state is cleared and game() is called
    again, as if the game was just started.


Keyboard Routines
-----------------

What would a game be without the ability for the player to control it?  This set
of functions allows your game to accept input via the keyboard, the most common
input method for a PC game.  First of all, the available keycodes:

    KEY_ESCAPE
    KEY_F1
    KEY_F2
    KEY_F3
    KEY_F4
    KEY_F5
    KEY_F6
    KEY_F7
    KEY_F8
    KEY_F9
    KEY_F10
    KEY_F11
    KEY_F12
    KEY_TILDE
    KEY_0
    KEY_1
    KEY_2
    KEY_3
    KEY_4
    KEY_5
    KEY_6
    KEY_7
    KEY_8
    KEY_9
    KEY_MINUS
    KEY_EQUALS
    KEY_BACKSPACE
    KEY_TAB
    KEY_A
    KEY_B
    KEY_C
    KEY_D
    KEY_E
    KEY_F
    KEY_G
    KEY_H
    KEY_I
    KEY_J
    KEY_K
    KEY_L
    KEY_M
    KEY_N
    KEY_O
    KEY_P
    KEY_Q
    KEY_R
    KEY_S
    KEY_T
    KEY_U
    KEY_V
    KEY_W
    KEY_X
    KEY_Y
    KEY_Z
    KEY_SHIFT
    KEY_CTRL
    KEY_ALT
    KEY_SPACE
    KEY_OPENBRACE
    KEY_CLOSEBRACE
    KEY_SEMICOLON
    KEY_APOSTROPHE
    KEY_COMMA
    KEY_PERIOD
    KEY_SLASH
    KEY_BACKSLASH
    KEY_ENTER
    KEY_INSERT
    KEY_DELETE
    KEY_HOME
    KEY_END
    KEY_PAGEUP
    KEY_PAGEDOWN
    KEY_UP
    KEY_RIGHT
    KEY_DOWN
    KEY_LEFT
    KEY_NUM_0
    KEY_NUM_1
    KEY_NUM_2
    KEY_NUM_3
    KEY_NUM_4
    KEY_NUM_5
    KEY_NUM_6
    KEY_NUM_7
    KEY_NUM_8
    KEY_NUM_9
    KEY_CAPSLOCK
    KEY_NUMLOCK
    KEY_SCROLLLOCK

GetPlayerKey(player, button);
SetPlayerKey(player, button, keycode);

    Gets or sets the keycode mapped to a specified playerkey.  Playerkeys mirror
    the layout of a Super NES controller.  GetPlayerKey() should be used in
    place of hardcoded keys whenever possible, in order to allow the player to
    customize the mappings.  'player' can be one of the following values:

        PLAYER_1 (or 0)
        PLAYER_2 (or 1)
        PLAYER_3 (or 2)
        PLAYER_4 (or 3)

    'button' can be one of the following:

        PLAYER_KEY_UP
        PLAYER_KEY_RIGHT
        PLAYER_KEY_DOWN
        PLAYER_KEY_LEFT
        PLAYER_KEY_MENU
        PLAYER_KEY_A
        PLAYER_KEY_B
        PLAYER_KEY_X
        PLAYER_KEY_Y

    Modifications made by SetPlayerKey() are persistent; the new mapping will be
    saved to your game's "save" directory when the engine exits and reloaded
    when the game is started again.  Key mappings for other games are not
    affected.

    See key-mapping.txt for more information on these functions and an easy way
    you can allow your players to change the key mappings.

GetToggleState(keycode);

    Gets the state of the specified toggle key, which should be one of the
    following:

        KEY_CAPSLOCK
        KEY_NUMLOCK
        KEY_SCROLLLOCK

    Passing any other keycode will throw an error.

IsKeyPressed(keycode);
IsAnyKeyPressed();

    Returns true if the user is currently pressing either a specified key, or
    any key on the keyboard, respectively.

AreKeysLeft();
GetKey();

    GetKey() returns the keycode of the next key in the keyboard queue.  If the
    queue is empty, it will wait until the user presses a key.  AreKeysLeft()
    returns true if keys are pending, and should be used to avoid delays if such
    behavior is undesirable.

ClearKeyQueue();

    Removes all keys from the keyboard queue.

BindKey(keycode, on_down_script, on_up_script);
UnbindKey(keycode);

    BindKey() executes a script whenever the player presses or releases a
    specified key.  The scripts can be either functions, source code strings, or
    null/undefined (to do nothing).  Note that bound keys are only honored
    during the main loop of a MapEngine() call.

    UnbindKey() removes a binding created by BindKey().


Joystick Routines
-----------------

These functions allow your game to accept joystick and gamepad input for a more
console-like experience.

GetNumJoysticks();

    Returns the number of joysticks currently available for use.

GetNumJoystickAxes(joystick);
GetJoystickAxis(joystick, axis);

    Gets the current position of a joystick axis.  'joystick' and 'axis' are
    zero-based indices whose exact meaning depends on the device and system.
    Return value ranges from -1.0 to 1.0, with zero indicating dead center.
    Call GetNumJoystickAxes() to get the number of available axes.

    Note: Joystick axis indices may differ from device to device.

GetNumJoystickButtons(joystick);
IsJoystickButtonPressed(joystick, button);

    Returns true if a specified joystick button is pressed.  'button' is a zero-
    based index whose exact mapping depends on the device and system.  Call
    GetNumJoystickButtons() to get the number of available buttons.

    Note: Joystick button indices may differ from device to device.

BindJoystickButton(joystick, button, on_down_script, on_up_script);
UnbindJoystickButton(joystick, button);

    Like BindKey() and UnbindKey() above, but binds a joystick button instead of
    a keyboard key.  As with BindKey(), bound joystick buttons are only honored
    in the main MapEngine() loop.


Mouse Input Routines
--------------------

Rounding out the input routines are the mouse functions. Most games don't need
mouse support, but it's available if you do need it.

GetMouseX();
GetMouseY();
SetMousePosition(x, y);

    Gets or sets the location of the mouse cursor, in pixels, relative to the
    game screen.

GetNumMouseWheelEvents();
GetMouseWheelEvent();

    GetMouseWheelEvent() returns the next mouse wheel event in the wheel queue.
    If the queue is empty, waits until the player moves the wheel. If this
    behavior is undesirable, call GetNumMouseWheelEvents() first to make sure
    the queue isn't empty.

IsMouseButtonPressed(button);

    Returns true if the player is pressing the specified mouse button. 'button'
    can be one of the following:

        MOUSE_LEFT:   Left button
        MOUSE_MIDDLE: Middle or wheel button
        MOUSE_RIGHT:  Right button


Random Number Generation
------------------------

Many games have need of a good random number generator, particularly RPGs.  All
JavaScript engines have a built-in generator in the form of the Math.random()
function; however, this is based on a very simple linear generator and produces
low-quality random numbers.  minisphere provides the RNG object, which uses the
MT19937 (Mersenne Twister) algorithm to generate high-quality random values and
also allows manual seeding.

RNG.chance(odds);

    Takes a chance and returns true or false depending on the outcome.  `odds`
    is a value in the range [0-1] and represents a percentage: 0.75, for
    instance, will pass 75% of the time.

RNG.normal(mean, sigma);

    Returns a random floating point value normally distributed around `mean`
    with a standard deviation of `sigma`.  The probability distribution of this
    function is sometimes termed a "bell curve."

RNG.random();

    Returns a floating point value in the range [0,1).  This is the basic method
    of random number generation, and is a direct, drop-in replacement for
    Math.random().

RNG.range(min, max);

    Returns a random integer uniformly distributed within the range [min,max].

RNG.sample(array);

    Returns a single randomly-chosen item from `array`.

RNG.seed(seed);

    Seeds the random number generator with `seed`.  If the seed is floating
    point, it will be truncated to an integer; using a seed of 812.88, for
    example, has the same effect as 812.

RNG.string([length]);

    Returns a randomly-generated string consisting of alphanumeric characters.
    The generated string looks something like a YouTube video hash (e.g.
    YlHRHDrKS) and is useful for uniquely identifying things, for example to
    generate temporary filenames.  If no length is provided, the default is 10.

RNG.uniform(mean, variance);

    Returns a random floating point value uniformly distributed around `mean`
    with absolute maximum deviation specified by `variance`.


Graphics Routines
-----------------

minisphere, like Sphere, uses double-buffered rendering.  In this scheme, all
drawing is done to a backbuffer, which is not visible to the user, and then
"flipped" once per frame, so that the player only sees the final rendering
output.

GetClippingRectangle();
SetClippingRectangle(x, y, width, height);

    Gets or sets the clipping rectangle. All rendering done to the backbuffer is
    constrained to this rectangle. Note that GetClippingRectangle() returns the
    current clipping rectangle as an object describing it, with `x`, `y`,
    `width` and `height` properties.

GetFrameRate();
SetFrameRate(fps);

    Gets or sets the current target frame rate. Your game will be automatically
    throttled to match this framerate. If `fps` is zero, the game will be
    unthrottled, which may be useful for benchmarks but otherwise is usually a
    waste of CPU resources.

GetScreenWidth();
GetScreenHeight();
SetScreenSize(width, height);

    Gets or sets the current screen resolution.

ApplyColorMask(color);

    Applies a full-screen color mask. The color passed in is multiplied with the
    pixels of the backbuffer to tint the screen. This may be used for, e.g.
    day/night effects.

FlipScreen();

    Flips the backbuffer.  This also performs event loop processing, so if it is
    not called regularly (or DoEvents() in its place, see above), the engine
    will stop responding.


Frame Skipping
--------------

minisphere has an aggressive frame skipping algorithm which avoids rendering
to the backbuffer if it determines that a frame will be late.  This helps keep
the engine running at full speed even on lower-end computers.  The following
functions are provided to manage frame skipping.

GetMaxFrameSkips();
SetMaxFrameSkips(max_skips);

    Gets or sets the maximum number of consecutive frames the engine is allowed
    to skip.  The default is 5 frames.  If your game uses GrabImage() or
    GrabSurface() pervasively, it may be useful to set this to zero.  This will
    almost certainly cause lag, however.

IsSkippedFrame();

    Returns true if the engine has marked the current frame for skipping. Useful
    to avoid performing extra rendering calculations when nothing is going to be
    rendered anyway.

UnskipFrame();

    Instructs the engine to re-enable rendering for the current frame if it has
    been marked for skipping.  This also clears the backbuffer.  This call can
    be used in lieu of SetMaxFrameSkips(0) during sections which make heavy use
    of GrabImage() or GrabSurface() without impacting performance for the rest
    of the game.


Galileo Graphics API
--------------------

Wondered what that `sphere-galileo` extension was above?  This is it!  It's a
more modern approach to graphics rendering based on precomposing scenes from
groups of shapes which can then be transformed and rendered as a unit.

All the old-school primitives provided by Sphere 1.5 are still available in
minisphere.  However, there's a newer, much more modern way: the Shape and Group
objects.  With these, you precompose a complex object out of a set of vertices
and textures which are then uploaded to the GPU to save time during the main
render loop.

new Color(red, green, blue[, alpha]);

    Constructs a new Color object.  Color objects are used to specify the color
    of elements such as vertices and primitives.  Color components should be in
    the range [0-255] and out-of-range values will be silently clamped.  `alpha`
    specifies opacity and defaults to 255 if not provided.

Color:clone();

    Copies this Color object to a new one.  Changes to the cloned object will
    not affect the original.

Color:red (read/write)
Color:green (read/write)
Color:blue (read/write)
Color:alpha (read/write)

    Gets or sets the individual components of the color.  Values outside the
    range of [0-255] are accepted, but the engine will automatically clamp them
    during rendering.

BlendColors(color1, color2);

    Averages two colors and returns the new Color object from the result.

BlendColorsWeighted(color1, color2, w1, w2);

    Returns a new Color object which is a weighted average of the two passed in.
    'w1' and 'w2' are the relative weights of the two colors.

new Image(filename);

    SphereFS compliant.

    Constructs a new Image object from an image file.  Images can be used as
    textures for Shape objects or drawn directly using the legacy method
    Image:blit().

    Images are read-only.  If you need a writable image, you should use a
    Surface object instead.

new Image(surface);

    Creates an Image object with the contents of a specified surface.  This can
    be used to regain rendering performance after composing the surface.

Image:width (read-only)
Image:height (read-only)

    Gets the width or height of the image, in pixels.

new Matrix();

    Constructs a transformation matrix.  The object represents a 4x4 matrix and
    is initialized as an identity matrix.

Matrix:identity();

    Initializes this matrix as an identity matrix.

Matrix:compose(otherMatrix);

    Multiplies this matrix by `otherMatrix`.

Matrix:rotate(theta);

    Applies a rotation transformation to this matrix.  `theta` is the angle of
    rotation, in radians.

Matrix:scale(sx, sy);

    Applies a scaling transformation to this matrix.  `sx` and `sy` are the
    horizontal and vertical scaling factors, respectively.

Matrix:translate(tx, ty);

    Applies a translation transformation to this matrix.  `tx` and `ty` are the
    horizontal and vertical translations, respectively.

new Shape(vertices[, texture[, primitive_type]]);

    Constructs a primitive shape out of the provided array of vertices textured
    with the Image specified by `texture`.

    Each vertex can have the following properties:

        vertex.x, vertex.y

            The location of the vertex.  The final location of each vertex can
            be modified by using a transformation matrix (see Matrix above).

        vertex.u, vertex.v

            The texture coordinates of the vertex.  This is used to control
            which part of the texture will be applied to this vertex.  If u/v
            is not provided for a vertex, it will be assumed to be have its u/v
            at (0, 0).

        vertex.color

            The color of the vertex.  The vertex colors will be multiplied with
            texture pixels to determine the final color of each pixel in a
            shape.

    `primitive_type` can be one of the following:

        SHAPE_AUTO

            Primitive type is determined automatically based on the number of
            vertices.  This is the default.

        SHAPE_POINTS

            A point list. Each vertex represents a single point to be rendered.
            Useful for particle effects.

        SHAPE_LINES

            A line list.  Each pair of vertices represents a line segment.

        SHAPE_TRIANGLES

            A triangle will be drawn for every 3 vertices.

        SHAPE_TRI_STRIP

            A triangle strip.  The first 3 vertices represent a complete
            triangle, and each subsequent vertex is combined with the previous
            two to form another.  Number of triangles drawn is equal to
            (num_verts - 2).

        SHAPE_TRI_FAN

            A series of triangles is drawn, all sharing the first vertex.  As
            with a strip, the total number of triangles is equal to
            (num_verts - 2).s

Shape:texture (read/write)

    The Image to be used when texturing the shape. This can be null, in which
    case the vertex colors alone will determine the rendered shape's
    appearance.

Shape:draw([surface[, transform]]);

    Draws the shape.  `surface` specifies the surface to drawn the shape on, or
    null to draw to the backbuffer.  `transform` is the Matrix to use to
    transform the shape.

new Group(shapes[, shader]);

    Constructs a Group out of the provided array of Shape objects.  `shader` is
    the shader program to use when rendering the group.  See below for more
    information on shaders.

    When a Group is created, its transformation matrix is set to the identity
    matrix.  If `shader` is not provided, the default shader program will be
    used (see `GetDefaultShaderProgram()`).

Group:shader (read/write)

    Gets or sets the ShaderProgram to use when drawing this group.

Group:transform (read/write)

    Gets or sets the transformation matrix to use when drawing this group.

Group:draw([surface]);

    Draws the group to the backbuffer. Any transformations defined for the
    group (see below) are applied as if the entire group were a single
    primitive.  `surface` specifies the Surface to draw on, or null for the
    backbuffer.

GetDefaultShaderProgram();

    Gets the default Galileo shader program.  This is a very barebones shader
    which uses screen coordinates for vertices and performs only basic texture
    mapping in the fragment shader.

new ShaderProgram(shader_files);

    SphereFS compliant.

    Constructs a ShaderProgram from a set of shader sources.  `shader_files`
    should be an object with the following properties:

        .vertex:   The filename of the source for the vertex shader.
        .fragment: The filename of the source for the fragment shader.


Color Matrices
--------------

A color matrix is used to transform indivual pixel colors similar to the way
matrices are used in graphics to transform points. Color matrices operate on the
individual color components (RGB) of the pixel, as follows:

    [ rn, rr, rg, rb ]   [r]    r' = rn + (rr * r + rg * g + rb * b) / 255
    [ gn, gr, gg, gb ] x [g]    g' = gn + (gr * r + gg * g + gb * b) / 255
    [ bn, br, bg, bb ]   [b]    b' = bn + (br * r + bg * g + bb * b) / 255

new ColorMatrix(rn, rr, rg, rb, gn, gr, gg, gb, bn, br, bg, bb);

    Constructs a new ColorMatrix object which can be used in color
    transformation operations.  All arguments are required and specify the
    contents of the matrix.

ColorMatrix.apply(color);

    Applies the matrix to the specified color value and returns the output
    color.


Surfaces
--------

A surface is a writable image to which you can render primitives, images and
even other surfaces in order to compose an image behind-the-scenes and later
render it all at once.  Surfaces are allocated from main memory, which allows
fast manipulation at the expense of direct rendering performance.

new Surface(width, height[, fill_color]);

    Constructs a new surface with the specified width and height, optionally
    filled with 'fill_color'.  If a fill color is not provided, the created
    surface will be filled with transparent pixels.

new Surface(filename);

    SphereFS compliant.

    Constructs a new surface from the specified image file.

GrabSurface(x, y, width, height);

    Creates a surface with the contents of the specified portion of the
    backbuffer. If this called during a skipped frame, the content of the
    created surface is undefined. See the documentation for the Frameskip API
    above for information on how to mitigate this.

Surface:width (read-only)
Surface:height (read-only)

    Gets the width or height of the surface, in pixels.

Surface:clone();

    Creates a new surface from the contents of this one. Modifications to the
    new surface will not affect the original.

Surface:save(filename);

    Not SphereFS compliant: `filename` is relative to ~sgm/images.

    Saves the contents of the surface to an image file.  The filename extension
    determines the format of the saved image.  Supported formats are PNG, BMP
    and JPG.


Windowstyles
------------

Windowstyles are used add flair to menus and text boxes, especially in RPGs.
You can create as many windowstyle objects as you want, so they provide a
standardized way to allow the player to customize the style of such elements in
a game.

new WindowStyle(filename);

    SphereFS compliant.

    Constructs a WindowStyle object from a windowstyle file. The file must be in
    Sphere RWS format.

WindowStyle:colorMask (read/write)

    Gets or sets the windowstyle color mask.  This is the color that is combined
    with the windowstyle images to tint the rendered window.  If this is not
    modified, the default color is #FFFFFFFF and the windowstyle will be
    rendered as-is.

WindowStyle:drawWindow(x, y, width, height);

    Renders a window to the backbuffer using this windowstyle.  Note that the
    dimensions provided include the window border, so you will need to make it a
    bit larger than your content.


Fonts and Text Rendering
------------------------

A common task in a game engine, at some point you will probably want to get text
on the screen.  In minisphere, you use a Font object to do this.

GetSystemFont();

    Returns a Font object for the engine's built-in default font.  This can be
    used in lieu of the Font constructor for prototyping--or even if you just
    prefer the default font.

new Font(filename);

    SphereFS compliant.

    Constructs a Font object from a font file. The file must be in Sphere RFN
    format.

Font:clone();

    Creates a new Font object by copying everything from this one.
    Modifications to the cloned font then won't affect the original.

Font:colorMask (read/write)

    Gets or sets the color mask, which is blended with the font bitmaps when
    text is rendered using the font.

Font:height (read-only)

    Gets the line height, in pixels, for text rendered using this font.

Font:getCharacterImage(cp);

    Gets an Image object for a specified character glyph.  `cp` is an integer in
    the range [0-255] specifying the ASCII character code.

Font:setCharacterImage(cp, image);

    Sets the glyph image for a specified character.  `cp` has the same meaning
    as above and `image` is the replacement Image object.  Note that replacing
    glyph images requires the font metrics to be recalculated, which may cause
    performance issues if overused.

Font:getStringWidth(string);

    Gets the width, in pixels, of `string` when it is rendered using this font.

Font:getStringHeight(string, wrap_width);

    Gets the height, in pixels, of the string when it is rendered using
    Font:drawTextBox(), passing `wrap_width`.

Font:wordWrapString(text, wrap_width);

    Wraps `text` as if it were drawn with Font:drawTextBox() with the specified
    wrap width.  Returns an array of strings, representing the lines of the
    wrapped string.

Font:drawText(x, y, text);

    Renders `text` at (x,y) using this font.  The text is not wrapped.

Font:drawZoomedText(x, y, scale, text);

    Renders `text` at (x, y) using this font, scaled according to `scale`. For
    example, a scale of 2.0 is double size.  As with Font:drawText(), the text
    is not wrapped.

Font:drawTextBox(x, y, width, height, x_offset, text);

    Renders `text` at (x, y) wrapped and constrained to a box of the specified
    width and height.  `x_offset` is added to the X coordinate to offset the
    text.


Audialis Sound Routines
-----------------------

Playing sounds and music are both handled in minisphere by Audialis, the
evolution of Sphere 1.x's audio subsystem.  Audialis allows you to create mixers
which can be used to adjust certain parameters across all sounds associated with
that mixer.  This is useful for implementing global volume controls, for
example.

GetDefaultMixer();

    Gets the default Audialis mixer.  The default mixer outputs 44.1 kHz 16-bit
    sound with two channels, i.e. CD quality.

new Mixer(frequency, bits[, channels]);

    Constructs a new Mixer object.  Any sounds played through the mixer will use
    the format specified by the parameters above.  `frequency` is the sample
    rate, `bits` specifies the bit depth (allowed values are 8, 16 and 24), and
    `channels` is the number of channels, ranging [1-7].  Channel counts of 5 or
    higher imply an additional LFE channel (i.e. 5.1, 6.1, 7.1).

    Do note that this creates a _hardware_ mixer.  If the requested format is
    not supported by the system, an error will be thrown ("unable to create
    hardware voice").

Mixer:volume (read/write)

    Gets or sets the output volume of the mixer. This will affect the volume of
    any sounds played through the mixer.

new Sound(filename[, mixer]);

    SphereFS compliant.

    Constructs a Sound object from the specified audio file.  Supported sound
    formats are Ogg Vorbis (.ogg), WAV, MOD, S3M, IT, and FLAC.  minisphere does
    not support mp3 or MIDI.

    `mixer`, if provided, specifies the mixer which will be used to play the
    sound.  If no mixer is specified, the built-in stereo mixer will be used.
    See GetDefaultMixer() above.

Sound:playing (read-only)

    true if the sound is currently playing, false otherwise.

Sound:length (read-only)

    Gets the length of the sound in microseconds.

Sound:mixer (read/write)

    Gets or sets the mixer used to play the sound.

Sound:pan (read/write)

    Gets or sets the current pan (balance). 0.0 is dead center, -1.0 is full
    left, and 1.0 is full right.

Sound:pitch (read/write)

    Gets the current relative pitch of the sound. 1.0 is normal.  Note that this
    is not a true pitch adjustment: the playback speed will be altered.

Sound:position (read/write)

    Gets or sets the playback position within the sound, in microseconds.

Sound:repeat (read/write)

    Gets or sets whether the sound will automatically repeat when it reaches the
    end.

Sound:seekable (read-only)

    Gets or sets whether the sound is seekable.  Currently all supported formats
    are seekable, so this will always be true.

Sound:volume (read/write)

    Gets or sets the current volume of the sound.  0.0 is silent, 1.0 is full
    volume.  Higher values are allowed, but may introduce distortion due to
    clipping.

Sound:pause();

    Pauses the sound.  If it is already paused, this has no effect.

Sound:play([is_looping]);

    Begins or resumes sound playback. The semantics of this function are a bit
    counterintuitive, but match the behavior of Sphere 1.5.  When called with no
    arguments, Sound:play() resumes a paused sound.  Otherwise, the sound is
    restarted from the beginning (even if it was already playing).  If
    `is_looping` is true, the sound will automatically repeat when playback
    ends.

Sound:reset();

    Seeks to the beginning of the stream.  Playback state is not altered; if the
    sound is playing at the time of this call, it simply starts over from the
    beginning.  Essentially, this has the same effect as setting Sound:position
    to zero.

Sound:stop();

    Stops the sound.  The playback position will be reset to the beginning, even
    if the sound was not playing.

new SoundStream([frequency[, bits[, channels]]]);

    Constructs a sound stream, which plays arbitrary sound data provided by the
    game at runtime.  This may be used, for example, to generate sound
    procedurally or add support for an unsupported audio format in script.
    `frequency` specifies the stream's sample rate and 'channels' the number of
    audio channels, ranging [1-7].  Channel counts of 5 and higher imply an
    additional LFE (subwoofer) channel.

    The default stream format is 8-bit 22050Hz with 1 channel.

SoundStream:bufferSize (read-only)

    Gets the total number of samples in the stream's buffer.

SoundStream:mixer (read/write)

    Gets or sets the mixer used to play the stream.

SoundStream:play([mixer]);

    Starts the stream playing. Ideally, some audio should be pre-buffered into
    the stream (see SoundStream:write() below) first to minimize the risk of
    buffer underrun.

    `mixer` is optional and specifies the mixer used to play the stream.  If no
    mixer is provided, Audialis will use the default mixer (see
    GetDefaultMixer()) to play the stream.

SoundStream:pause();

    Temporarily pauses playback of the stream.

SoundStream:stop();

    Stops playback of the stream and frees its buffer.  This should be called
    when you are done using a stream.  The stream may be reused after a stop()
    call, but you will have to feed new audio data.

SoundStream:write(data);

    Writes audio data to the stream buffer.  `data` is an ArrayBuffer,
    TypedArray or DataView containing the data to write.  Audio data must be fed
    into a stream continuously while it is playing to prevent interruption.


Byte Arrays
-----------

A byte array is a buffer containing raw data. Byte arrays are used for both
networking as well as in binary file I/O.  See the sections below for more
information about those.  Byte arrays can be used like any other array, via the
indexing operator [], however values written to the array must be numeric and
are automatically coerced to 8-bit integers (range 0-255).

As of minisphere 2.0, the ByteArray object is deprecated and has been retained
only for backwards compatibility.  New games should use the native JavaScript
ArrayBuffer, TypedArray, or DataView objects instead.

new ByteArray(num_bytes);

    Constructs a byte array which can hold 'num_bytes' of data.  A byte array
    cannot be resized after it is created, so you will have to plan ahead to
    choose the right size.  Note that byte arrays start out empty, with all
    bytes set to zero.

new ByteArray(string);

    Constructs a byte array from the bytes of the provided string.  The size of
    the created byte array will be the number of bytes in the string (which may
    be greater than the string length!).

ByteArray:length (read-only)
ByteArray:size (read-only)

    Gets the size of the byte array, in bytes.

ByteArray:concat(byte_array);

    Returns a new byte array which is the result of appending 'byte_array' to
    the end of the one this method is called for.

ByteArray:deflate([level]);

    Compresses the data in the byte array using the zlib deflate algorithm and
    returns a new ByteArray containing the compressed data. 'level' specifies
    the relative compression level in the range [0-9].  If not provided, a
    default level is used (usually 6).

ByteArray:inflate([max_size]);

    Decompresses a byte array containing deflated data.  If the byte array
    doesn't contain valid compressed data such as generated by deflate(), an
    error will be thrown.  `max_size` specifies the maximum size of the
    uncompressed data.  If it is omitted, the inflate buffer will be dynamically
    sized to fit the data.

    Important: It is recommended to provide a maximum buffer size to inflate()
               whenever possible.  Not doing so leaves your game vulnerable to
               zip bomb-style exploits.

ByteArray:resize(new_size);

    Resizes the byte array to hold the specified number of bytes. The existing
    contents are preserved to the extent possible, and if the new size is
    larger, all additional bytes will be set to zero.

ByteArray:slice(start[, end])

    Returns a new byte array which is the result of copying all bytes between
    start and end, exclusive. If 'end' is negative, it is relative to the end of
    the byte array; if it is omitted, the entirety of the array from 'start'
    onwards is taken.

CreateStringFromByteArray(byte_array);

    Builds a string from the bytes in 'byte_array'.


Networking (Sockets)
--------------------

minisphere includes an advanced sockets API which is more flexible than the one
Sphere provides.  The old routines are still available, but should be considered
deprecated.  Under minisphere, sockets are divided into two types: Listening
sockets, used for servers, and I/O sockets, for clients.

GetLocalName();

    Returns the calling machine's network name.

GetLocalAddress();

    Returns the calling machine's local IP address.

new ListeningSocket(port[, backlog_size]);

    Constructs a new listening socket which listens for connections on `port`.
    `backlog_size` specifies the size of the backlog. If the backlog fills, new
    connections will be dropped.

ListeningSocket:accept();

    If one or more connections are waiting in the backlog, accepts one of them
    and returns an IOSocket object representing the connection.  Otherwise,
    returns null.  This should be called regularly to prevent the backlog from
    filling up.

ListeningSocket:close();

    Disconnects the socket. Any sockets in the backlog will be purged and no new
    connections can be made unless a new ListeningSocket is created.

new IOSocket(hostname, port);

    Connects to `hostname` on `port` and constructs an IOSocket representing the
    connection.  The hostname can either be a named address (e.g. google.com) or
    an IP address (e.g. 127.0.0.1).  As this operation is non-blocking, a valid
    socket will be returned even if the connection can be not be made; you must
    call IOSocket:isConnected() to find out when the connection has opened.

IOSocket:remoteAddress (read-only)

    Gets the IP address of the upstream end of the socket.  Throws an error if
    accessed before a connection has been established.

IOSocket:remotePort (read-only)

    Gets the port that the remote machine is using for the connection.
    Generally not a useful statistic, but it's there if you need it.  Throws an
    error if accessed before a connection is established.

IOSocket:isConnected();

    Returns true if a connection has been established.  As long as this returns
    false, you cannot call any other methods on the socket object.  Doing so
    will cause an error to be thrown.

IOSocket:getPendingReadSize();

    Gets the amount of data, in bytes, currently in the receive buffer.  Call
    IOSocket:read() or :readString() to retrieve this data.

IOSocket:pipe(destination);

    Automatically pipes the data received by the socket to the specified
    destination socket.  Piping a socket into itself will create an echo server.
    Note that only one pipe can be active at a time for a given socket; calling
    pipe() multiple times will simply change the destination.

IOSocket:read(bytes);

    Reads up to `bytes` bytes from the socket and returns a ByteArray containing
    the data received.

IOSocket:readString(bytes);

    Same as IOSocket:read(), but returns a string instead of a ByteArray. This
    may be more convenient, depending on your use case.

IOSocket:unpipe();

    Reverses the effect of a pipe() call and closes the pipe.  read() can be
    called normally afterwards.

IOSocket:write(data);

    Writes data to the socket, which can be read at the other end.  `data` can
    be either a ByteArray, ArrayBuffer, TypedArray, or string.

    If a string is provided, it will be written encoded as UTF-8.

IOSocket:close();

    Disconnects the socket.  Note that a socket object cannot be reused after it
    has been closed; a new one must be created.


File and Directory Management
-----------------------------

These functions allow you to manage the file system. For all of these functions,
file and directory names are relative to ~sgm/save.

GetFileList([dirname]);

    Not SphereFS compliant.  `dirname` is relative to ~sgm/.

    Returns an array of strings naming files found in the specified directory.
    If `dirname` is not provided, ~sgm/save is assumed.

GetDirectoryList([dirname]);

    Not SphereFS compliant.  `dirname` is relative to ~sgm/.

    Returns an array of strings naming subdirectories found in the specified
    directory.  If 'dirname' is not provided, ~sgm/ is assumed.  This is
    inconsistent with GetFileList(), but is compatible with Sphere 1.x.

DoesFileExist(filename);

    Returns true if the specified file exists, false otherwise.

CreateDirectory(dirname);

    Recursively creates a directory.  It is safe to call this function if the
    directory already exists.  In that case, nothing happens.

RemoveDirectory(dirname);

    Removes the specified directory from the file system.  The directory must be
    empty, otherwise an error will be thrown.

RemoveFile(filename);

    Deletes a file from the file system.  If the file cannot be deleted, an
    error will be thrown.

Rename(filename, new_filename);

    Renames a file on the file system.  If the file cannot be renamed, an error
    will be thrown.


File I/O
--------

When developing a game, at some point you will need to be able to read and write
data to a file, whether to save and load game progress or something else.

new KevFile(filename);

    Opens a kevfile.  The file format used for kevfiles is similar to a Windows
    INI file, containing key/value pairs separated by an equals sign, for
    instance:

        playerName=maggie
        playtime=812:00:00
        currentMap=foodville.rmp
        # etc.

KevFile:read(key, defval);

    Reads a value from the kevfile.  If the key doesn't exist in the file,
    `defval` is returned.  The return type depends on the type of `defval`,
    either boolean (true/false), number, or string.

KevFile:write(key, value);

    Writes a value to the kevfile under a specified key.  If the key already
    exists, it will be overwritten.  Writes are cached, and not written to the
    file until flushed, either by calling KevFile:flush() or automatically when
    it is closed.

KevFile:flush()

    Flushes the file.  All pending changes will be written out to the file on
    disk.  The file will remain open afterwards.

KevFile:close()

    Closes the file, writing any changes out to the file on disk in the process.
    You should not call any other methods on the object after this (it is safe
    to call KevFile:close() more than once, however).  Doing so will throw an
    error.

new RawFile(filename[, is_writable]);

    SphereFS compliant.

    Opens a binary file, allowing raw data to be read and/or written.  If
    `is_writable` is false, the file must exist and will be opened for reading
    only.  Otherwise, the file is overwritten (be careful!) and opened for
    writing.  If it cannot be opened for writing, an error will be thrown.

RawFile:position (read/write)

    Gets or sets the current file position.  This determines where the next read
    or write operation will start.

RawFile:size (read-only)

    Gets the current size of the file in bytes.  Can also be specified as
    RawFile:length.

RawFile:read([num_bytes]);

    Reads data from the file and advances the file position.  `num_bytes`
    specifies the amount of data to read; it can be omitted to read the entire
    file at once (the file position will not change in this case).  Returns a
    ByteArray.

RawFile:readString([num_bytes]);

    Like RawFile:read(), but returns a UTF-8 string instead of a ByteArray.
    This may be more convenient in some cases.

RawFile:write(data);

    Writes data to the file and advances the file position.  The file must be
    opened for writing or an error will be thrown.  `data` can be either a
    ByteArray, ArrayBuffer, TypedArray, or string.

    If a string is provided, it will be written encoded as UTF-8.

RawFile:close();

    Closes the file.  You should not call any other methods on the object after
    this (it is safe to call RawFile:close() more than once, however).  Doing so
    will throw an error.


File Streams
------------

The RawFile object documented above was deprecated in minisphere 2.0 and is now
retained only for backwards compatibility with Sphere 1.x. New games should
instead use the much more flexible FileStream object.

The FileStream API is fully SphereFS compliant.

new FileStream(filename, mode);

    Constructs a new FileStream from the specified file.  `mode` is a string in
    the same format as that of C fopen() specifying how to open the file:

        r:  Open file for reading.
        r+: Open file for update (reading and writing).
        w:  Create/truncate then open file for writing.
        w+: Create/truncate then open file for update.
        a:  Open file (create if not found) with file position at end of file.
        a+: Open file for update with initial position at end of file.

    A valid mode must be provided, otherwise stream construction will fail and
    throw an error.

FileStream:length (read-only)
FileStream:size (read-only)

    Gets the size of the underlying file, in bytes.

FileStream:position (read/write)

    Gets or sets the file position, which determines where in the file the next
    read or write will start from.  Expressed in bytes.

    Note: For files opened for writing, it is valid to seek past the end of the
    stream.  In this case the next write operation will be done at the new
    position and the gap filled with NUL bytes.

FileStream:close();

    Closes the stream, after which the FileStream object should not be used.
    Attempting to read or write to a stream after it is closed will throw an
    error.

FileStream:read([numBytes]);

    Reads data from the file, up to the specified number of bytes, and returns
    it in an ArrayBuffer.  As a convenience, `numBytes` can be omitted to read
    the entire file without affecting the file position. The file must be opened
    for reading.

FileStream:readFloat([little_endian]);
FileStream:readDouble([little_endian]);

    Reads a floating point value from the file and advances the file pointer.
    `little_endian` is optional and defaults to false.

FileStream:readInt([size[, little_endian]]);
FileStream:readUInt([size[, little_endian]]);

    Reads a signed or unsigned integer from the file and advances the file
    pointer.  `size` is an integer [1-6] and specifies the size in bytes of the
    value to read.  This allows integer values of up to 48 bits to be read.

FileStream:readPString(lenSize[, little_endian]);

    Reads a length-prefixed (Pascal) string from the file.  `lenSize` specifies
    the number of bytes [1-4] used to encode the string length.  `little_endian`
    is optional and defaults to false.

FileStream:readString([numBytes]);

    Reads a fixed-length string from the file.  `numBytes` specifies how many
    bytes to read and can be omitted to read the entire file at once without
    affecting the file pointer.

    Note: Strings in minisphere are UTF-8 encoded.  As a result, the number of
          bytes in a string may not match the number of characters.

FileStream:write(data);

    Writes data to the file and advances the file pointer.  `data` should be an
    ArrayBuffer, TypedArray or DataView containing the data to be written.

FileStream:writeFloat(value[, little_endian]);
FileStream:writeDouble(value[, little_endian]);

    Writes a floating point value to the file and advances the file pointer.
    `little_endian` is optional and defaults to false.

FileStream:writeInt(value[, size[, little_endian]]);
FileStream:writeUInt(value[, size[, little_endian]]);

    Writes a signed or unsigned integer to the file and advances the file
    pointer.  `size` is an integer [1-6] and specifies the size in bytes of the
    value to write.  This allows integer values of up to 48 bits to be written.

    Note: If `value` is too large or small to be represented in `size` bytes,
          this method will throw a TypeError.

FileStream:writePString(string, lenSize[, little_endian]);

    Writes a UTF-8-encoded, length-prefixed (Pascal-style) string to the file
    and advances the file pointer.  `lenSize` specifies the number of bytes [1-4]
    used to encode the string length.  `little_endian` is optional and defaults
    to false.

    Note: If the string is too long for its length to be encoded in `lenSize`
		  bytes, this method will throw a TypeError.

FileStream:writeString(string);

    Writes a UTF-8-encoded string to the file and advances the file pointer.


Map Engine
----------

minisphere's map engine is fully compatible with the one found in Sphere 1.5 and
very powerful.  It's also very easy to get up and running. This section is
incomplete; the APIs below are only the basics. See the Sphere 1.x API reference
for the full set of map functions.

MapEngine(filename[, framerate]);

    Not SphereFS compliant: `filename` is relative to ~sgm/maps.

    Starts the map engine, loading `map_file` as the initial map.  `framerate`
    specifies the framerate the map engine will run at; a framerate of 0 will
    run unthrottled, which may be useful for benchmarks but is generally useless
    otherwise.

    Unlike Sphere 1.x, `framerate` is optional.  If it is not provided, the
    FlipScreen() framerate (set using SetFrameRate()) will be used.

IsMapEngineRunning();

    Returns true if the map engine is currently running.

ChangeMap(filename);

    Not SphereFS compliant: `filename` is relative to ~sgm/maps.

    Loads a new map into the map engine.  This destroys any transient persons
    automatically.  Transient persons are those defined in the map file as well
    as any created by passing `true` as the third argument to CreatePerson().

MapToScreenX(layer, x);
MapToScreenY(layer, y);
ScreenToMapX(layer, x);
ScreenToMapY(layer, y);

    Converts between map and screen coordinates.

SetUpdateScript(fn);
SetRenderScript(fn);

    Sets a function `fn` to be called once per map engine frame.  Game state
    should be updated in the update script, while drawing is done in the render
    script.  The distinction is important, as render calls can be skipped to
    minimize lag.

    Note: You shouldn't call these functions when using miniRT.  The runtime
    uses update and render scripts internally and switching them out will break
    things.

SetMapEngineFrameRate(fps);
GetMapEngineFrameRate();

    Gets or sets the map engine framerate.  Set it to 0 to run the map engine
    unthrottled (not generally useful outside of benchmarks).

GetCurrentMap();

    Gets the filename of the current map, relative to ~sgm/maps.

SetLayerWidth(layer, width);
SetLayerHeight(layer, height);
SetLayerSize(layer, width, height);
GetLayerWidth(layer);
GetLayerHeight(layer);

    Gets or sets the size, in tiles, of the specified map layer.  Newly created
    map tiles will be set to use tile number 0 (the first image in the tileset).
    The change persists until the next ChangeMap() call.

    Note: If a map becomes smaller as a result of resize calls, zones and
    triggers which are fully outside the map will be deleted.  Any zones which
    are only partially out-of-bounds will be resized to fit.

AttachInput(name);
DetachInput();
IsInputAttached();
GetInputPerson();

    Attaches, detaches or gets the input focus.  The player will have control of
    the person with input focus.  `name` is the name of the person as passed to
    CreatePerson().

AttachCamera(name);
DetachCamera();
IsCameraAttached();
GetCameraPerson();

    Attaches, detaches, or gets the camera focus.  The camera will remain
    centered on whichever person it's attached to as they move about the map.
    `name` is the name of the person as passed to CreatePerson().

SetCameraX();
SetCameraY();
GetCameraX();
GetCameraY();

    Gets or sets the camera position. Note: If the camera is placed beyond the
    edge of a non-repeating map, the map's corresponding edge script will be
    called.

UpdateMapEngine();

    Updates the map engine per frame. Used to keep the map engine operating in
    the background when running a tight loop. Note that map input will not be
    accepted during an UpdateMapEngine() loop.

RenderMap();

    Renders the current map and set of persons to the backbuffer. Used along
    with UpdateMapEngine() to keep the map engine operating when running a tight
    loop.

ExitMapEngine();

    Tells the map engine to shut down at the start of the next frame.  If the
    map engine is presently held up in an UpdateMapEngine() loop (see below),
    this call will not take effect until control returns to the map engine
    proper.


Trigger Management
------------------

A trigger is a non-obstructing entity which automatically executes custom code
when stepped on by a player-controlled person. This is useful for triggering
events when the player reaches a certain point while exploring, as well as
implementing warp points between maps.

Note that trigger modifications at runtime are transient. This means they will
need to be redone if the map is reloaded. Persistent modifications require
triggers to be edited in the map file itself.

GetCurrentTrigger();

    When called in a trigger script, returns the trigger ID of the executing
    trigger. Calling this in any other context will throw an error.

AddTrigger(x, y, layer, script);

    Adds a trigger to the current map and returns its trigger ID.  `script` can
    be either a code string or a function.  Triggers created this way are
    transient and will need to be recreated if the map is reloaded.  For
    compatibility reasons, the layer is ignored by the engine when processing
    triggers.

RemoveTrigger(trigger_id);

    Removes the trigger with the specified trigger ID from the map.  As with
    AddTrigger(), the modification is transient.

GetNumTriggers();

    Gets the number of triggers on the current map.

GetTriggerX(trigger_id);
GetTriggerY(trigger_id);
GetTriggerLayer(trigger_id);
SetTriggerXY(trigger_id, x, y);
SetTriggerLayer(trigger_id, layer);

    Gets or sets the location of a trigger on the map, in pixels.

SetTriggerScript(trigger_id, script);

    Sets the specified trigger's script. Like most trigger modifications, this
    is transient.

IsTriggerAt(x, y, layer);

    Returns true if there is a trigger at the specified location, false
    otherwise.  'layer' is required, but ignored for compatibility reasons.

ExecuteTrigger(x, y, layer);

    Fires the trigger at the specified location, if one exists.  As above,
    `layer` is required but ignored.


Zone Management
---------------

Zones are similar to triggers, except they can cover more than one tile and run
their associated scripts periodically as long as the player is moving and
remains inside the zone. A potential use for these is implementing random
battles.  They have other uses as well, as demonstrated by, e.g., Lithonite.

As with triggers, all zone modifications at runtime are transient.

GetCurrentZone();

    When called in a zone script, returns the zone ID of the executing zones.
    Calling this in any other context will throw an error.

AddZone(x, y, width, height, layer, script);

    Adds a zone to the current map.  `script` can be either a code string or a
    function.  As with triggers, the layer is ignored by the engine when
    processing zones.

RemoveZone(zone_id);

    Removes the zone with the specified zone ID from the map.

GetNumZones();

    Returns the number of zones on the current map.

GetZoneX(zone_id);
GetZoneY(zone_id);
GetZoneWidth(zone_id);
GetZoneHeight(zone_id);
GetZoneLayer(zone_id);
SetZoneMetrics(zone_id, x, y, width, height[, layer]);

    Gets or sets the location and size of a zone, in pixels.

GetZoneSteps(zone_id);
SetZoneSteps(zone_id);

    Gets or sets the zone's step count.  The zone script will execute every time
    the input character takes this number of steps while inside the zone.

AreZonesAt(x, y, layer);

    Returns true if the specified point is inside of a zone, or false otherwise.
    'layer' is required, but ignored for compatibility reasons.

ExecuteZones(x, y, layer);

    Executes the scripts of all zones straddling the specified point, if any.
    As above, 'layer' is required but ignored.


Persons Management
------------------

Persons are the Sphere term for what most RPG map engines call 'entities'.  They
are so named for their typical use case--representing persons on a map.
Typically you create one or more persistent persons to represent your player
characters, and the rest are transient, to be destroyed when a new map is
loaded.

CreatePerson(name, spriteset, transient);

    Not SphereFS compliant: `spriteset` is relative to ~sgm/spritesets.

    Creates a person using the spriteset specified by `spriteset`.  This can
    either be an .rss spriteset filename or a Spriteset object.  If `transient`
    is true, the person is transient and will automatically be destroyed when a
    new map is loaded via ChangeMap().

DestroyPerson(name);

    Destroys the person, removing it from play.  This works on persons created
    manually via CreatePerson() as well as those created during map load, so be
    careful!

GetPersonList();

    Returns an array of person names representing all the persons that currently
    exist.

DoesPersonExist(name);

    Returns true if a person named `name` currently exists, otherwise returns
    false.

GetPersonX(name);
GetPersonY(name);
GetPersonLayer(name);
SetPersonX(name, new_x);
SetPersonY(name, new_y);
SetPersonLayer(name, layer);

    Gets or sets a person's position relative to the current map.  `layer` can
    be either a 0-based layer index or a layer name.  Note: For compatibility
    reasons, GetPersonLayer() always returns the index.

SetPersonXYFloat(name, new_x, new_y);
GetPersonXFloat(name);
GetPersonYFloat(name);

    Gets or sets a person's position relative to the current map, with subpixel
    precision.

SetPersonDirection(name, new_dir);
GetPersonDirection(name);

    Gets or sets a person's current direction.  The "direction" is actually the
    name of a pose as defined in the person's spriteset.  Note: A spriteset is
    required to have a pose for at least each of the 4 cardinal directions
    (north, east, south and west).

FollowPerson(name, leader_name, distance);

    Makes a person follow another person at a distance specified by `distance`.
    The distance is not absolute and the actual trailing distance depends on the
    leader's speed.  Faster leaders will put more distance between themselves
    and their followers.

    To detach a follower and make them independent again, call the function
    again like this:

        FollowPerson("<name>", null, 0);

GetPersonLeader(name);

    Gets the person `name` is currently following.  If no leader exists (the
    person is independent), returns an empty string ("").

GetPersonFollowers(name);

    Gets an array of names of persons following a specified person.

GetPersonFollowDistance(name);
SetPersonFollowDistance(name);

    Gets or sets the named person's follow distance.  Throws an error if the
    person is not following anyone.

IsPersonVisible()
SetPersonVisible(is_visible)

    Gets or sets the person's visibility status.  `true` if visible, `false` if
    not.

IsPersonObstructed(name, x, y);

    Checks whether the person would be obstructed at a given location.  Useful
    for pathfinding.

GetObstructingPerson(name, x, y);

    If the person named `name` is obstructed by a person at the given location,
    returns the offending person's name.  Otherwise, returns an empty string.

GetObstructingTile(name, x, y);

  If the person named `name` is obstructed by a map tile at the given location,
  returns the tile index.  Otherwise, returns -1.

SetPersonSpeed(name, speed);
SetPersonSpeedXY(name, new_speed_x, new_speed_y);
GetPersonSpeedX(name);
GetPersonSpeedY(name);

    Gets or sets the person's speed in two dimensions.  This function is
    shorthand for SetPersonSpeedXY(name, speed, speed).

SetPersonSpriteset(name, spriteset);
GetPersonSpriteset(name);

    Gets the person's current spriteset as a Spriteset object.

IsIgnoringPersonObstructions(name);
IgnorePersonObstructions(name, ignore);

    Gets or sets whether the person is ignoring other persons.  Ignored persons
    do not affect collision and cannot be talked to.  Note that ignoring is
    mutual between persons.

IsIgnoringTileObstructions(name);
IgnoreTileObstructions(name, ignore);

    Gets or sets whether the person is ignoring tile obstructions.  As with
    ignored persons, this disables tile collision.

QueuePersonCommand(name, command[, is_immediate]);

    Adds a command to the person's command queue. If `is_immediate` is true, the
    engine will immediately execute the next command in the queue. Otherwise,
    execution will halt until the next frame.  The default is false. The
    following commands are supported:

        COMMAND_WAIT - do nothing, useful as a non-immediate command to delay for
                       a frame.

        COMMAND_ANIMATE - advance the person's animation state by one frame.
                          Queue these continuously to animate the sprite.

        COMMAND_FACE_NORTH
        COMMAND_FACE_NORTHEAST
        COMMAND_FACE_EAST
        COMMAND_FACE_SOUTHEAST
        COMMAND_FACE_SOUTH
        COMMAND_FACE_SOUTHWEST
        COMMAND_FACE_WEST
        COMMAND_FACE_NORTHWEST

            Changes the person's facing direction.  If the specified direction
            isn't available in the person's spriteset, the engine will use the
            closest match.

        COMMAND_MOVE_NORTH
        COMMAND_MOVE_NORTHEAST
        COMMAND_MOVE_EAST
        COMMAND_MOVE_SOUTHEAST
        COMMAND_MOVE_SOUTH
        COMMAND_MOVE_SOUTHWEST
        COMMAND_MOVE_WEST
        COMMAND_MOVE_NORTHWEST

            Moves the person a number of pixels determined by their speed.  See
            SetPersonSpeed() above.

QueuePersonScript(name, script[, is_immediate]);

  Adds a script to the person's command queue.  `is_immediate` has the same
  meaning and semantics as in QueuePersonCommand() above.  `script` can be
  either a JavaScript source string or a function.

IsCommandQueueEmpty(name);

    Returns true if the person's command queue is empty, false otherwise.

ClearCommandQueue(name);

  Removes all commands and scripts from the person's command queue.


Tileset Management
------------------

These functions aren't generally needed for most use cases.  They are used to
modify the current map's tileset.  As with most map modifications, these are
transient and must be redone if the map is reloaded.

GetNumTiles();

    Returns the number of the tiles in the current map's tileset.

GetTileDelay(tile_id);
SetTileDelay(tile_id, frames);

    Gets or sets a tile's animation delay.  This is the number of frames which
    must elapse before the tile switches to the next one in its animation
    sequence.

GetNextAnimatedTile(tile_id);
SetNextAnimatedTile(tile_id, next_tile_id);

    Gets or sets the next tile in the tile animation sequence.

GetTileImage(tile_id);
SetTileImage(tile_id, image);

    Gets or sets the Image associated with a tile.  The dimensions of the Image
    must match the tile dimensions, or an error will be thrown.

GetTileSurface(tile_id);
SetTileSurface(tile_id, surface);

    Like Get/SetTileImage(), but uses Surface objects instead.  Note: Drawing to
    the Surface after calling either of these functions will not modify the
    tile.
