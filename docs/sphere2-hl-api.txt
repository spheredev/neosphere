Sphere Runtime API Reference
============================

Besides the low-level Core API, the Sphere platform also includes a set of
standard objects used for higher-level tasks, collectively known as the
Sphere Runtime.  This file documents the API.


`assert` Function
-----------------

An implementation of the standard CommonJS assertions module.  Assertions are
useful both for making unit tests as well as verifying that runtime conditions
match development assumptions.  By writing an assertion, you are asserting that
the condition is true (hence the name); if that turns out not to be the case,
an AssertionError will be thrown instead of continuing normal operation.  With
strategic placement of assertions, bugs can be uncovered faster.

Each assertion function accepts an optional `error_text` parameter.  This
specifies the error message to use if an AssertionError gets thrown.  If no
message is specified, a default message will be used approximating the
offending expression, e.g. "AssertionError: 2 < 1"

    import { assert } from 'sphere-runtime';
    const assert = require('assert');

assert(condition[, error_text]);
assert.ok(condition[, error_text]);

    Asserts that a boolean expression evaluates to true.

assert.deepEqual(value, expected[, error_text]);
assert.deepStrictEqual(value, expected[, error_text]);

    Asserts that two objects are equivalent.  Objects are equivalent if and
    only if they have the same own properties, their subobjects have the same
    own properties, etc. and all properties with primitive values are equal in
    value according to either the equality operator (==) or strict equality
    operator (===), respectively.

    Note: `assert.deepStrictEqual()` has an additional requirement that the
          objects must have the same prototype.  `assert.deepEqual()`, by
          contrast, doesn't look at the objects' prototypes at all.

assert.equal(value, expected[, error_text]);
assert.strictEqual(value, expected[, error_text]);
assert.notEqual(value, unexpected[, error_text]);
assert.notStrictEqual(value, expected[, error_text]);

    Asserts that two values either match or do not match, respectively.
    The standard variants test for loose equality (`==`), while the "strict"
    variants test for strict equality (`===`).

assert.throws(func, expected[, error_text]);
assert.doesNotThrow(func, expected[, error_text]);

    Asserts that the specified function either throws or does not throw a
    specified class of exception.  `expected` can either be an error
    constructor such as `TypeError` or `ReferenceError`, or a predicate
    function.  If it's a predicate function, the function should return true if
    the thrown exception matches, or false otherwise.

    Note: To avoid suppressing unrelated exceptions, any exception that doesn't
          match the specified criteria will be rethrown as-is.


`from` Function
---------------

The `from` function provides games with the ability to perform complex queries
against the contents of arrays and objects.  One use case is in battle engines:
you could, for instance, query for only those battlers on the enemy side, or
use a query to narrow down the scope of status effects.  Even enemy AI code can
benefit from queries!

    import { from } from 'sphere-runtime';
    const from = require('from');

If you're familiar with C#, the from() function exposed by this module works a
lot like LINQ.  A query is built from a number of predicates and mappings, and
is then typically processed using a `for...of` loop.

For example, suppose you wanted to code an attack that damages all opposing
battlers whose level is a multiple of 5, but only hits 75% of the time.  That
could look like this:

    let targets = from(battlers)
        .where(v => v.isEnemyOf(attacker))
        .where(v => v.level % 5 == 0)
        .where(v => random.chance(0.75));
    for (let target of targets) {
        target.damage(move.power * attacker.strength);
    }


from(source[, ...]);

    Constructs a FromQuery against one or more arrays or objects.  The
    enumeration mode for each source depends on whether it's a plain object,
    iterable object, or array-like; if you need a specific enumeration mode,
    you should use one of the specialized calls below and work through one at a
    time.

from.Array(array);

    Constructs a FromQuery against an array or array-like object.  `array` must
    have a number-valued `length` property, and only sequential integer keys in
    the range [0,length) will be enumerated.

    Throws a TypeError if the object either doesn't have a `length` property or
    its value is non-numeric.

from.Object(object);

    Constructs a FromQuery against an ordinary JavaScript object.  Only
    enumerable own properties of the object will be queried.  Non-enumerable
    and inherited properties will be ignored.

from.iterable(source);

    Constructs a FromQuery against an iterable object.  Iterable objects are
    those implementing the JavaScript "iterable protocol"; in other words,
    objects implementing `[Symbol.iterator]`.  `from()` queries are themselves
    iterable.

from#all(predicate);

    Runs the query, calling `predicate` for each result.  The predicate should
    return a boolean value (true or false); if and only if all items match the
    predicate, all() returns true.  Otherwise it returns false.

    Note: If there are no results, all() returns true.  This operation is
          short-circuiting: the first non-matching item terminates the query.

from#allIn(values);

    Runs the query and returns true if and only if all results match a value
    in the array `values`, otherwise returns false.

    Note: If there are no results, allIn() returns true.  This operation is
          short-circuiting: the first non-matching item terminates the query.

from#any(predicate);

    Runs the query, calling `predicate` for each result.  The predicate should
    return a boolean value (true or false); if any item matches the predicate,
    any() returns true.  Otherwise it returns false.

    Note: If there are no results, any() returns false.  This operation is
          short-circuiting: the first matching item terminates the query.

from#anyIn(values);

    Runs the query and returns true if any results matches a value in the
    array `values`, otherwise returns false.

    Note: If there are no results, anyIn() returns false.  This operation is
          short-circuiting: the first matching item terminates the query.

from#anyIs(value);

    Runs the query and returns true if any result matches the given value,
    otherwise returns false.

    Note: If there are no results, anyIs() returns false.  This operation is
          short-circuiting: the first matching item terminates the query.

from#ascending([keySelector]);

    Calls `keySelector` to get a sort key for each result and orders the
    results in ascending order (least to greatest) by key.  If no key selector
    is provided, the result itself is used as the key.

    Note: from#ascending() performs a stable sort: items with the same key
          remain in the same relative order.  This allows chained ordering
          operators to work as expected.

from#besides(callback);

    Calls `callback` for each result, ignoring the return value and passing on
    the result as is.  This is useful if you need to perform ancillary actions
    in the middle of a query; for example, tallying intermediate results.

    Note: Avoid causing side effects that modify the query source.  Bad things
          can happen otherwise! (such as: the pig eating you)

from#count([predicate]);

    Runs the query, returning the number of results.  `predicate` is optional;
    if provided, it should return true to count the result, or false to exclude
    it.  If no predicate function is provided, all results are counted.

from#descending([keySelector]);

    Calls `keySelector` to get a sort key for each result and orders the
    results in descending order (greatest to least) by key.  If no key selector
    is provided, the result itself is used as the key.

    Note: from#descending() performs a stable sort: items with the same key
          remain in the same relative order.  This allows chained ordering
          operators to work as expected.

from#each(callback);

    Runs the query, calling `callback` for each result.  The return value of
    the callback is ignored.  This is used to loop over the results of a query,
    the way you would loop over an array using arrayObj.forEach() in standard
    JavaScript.

    Note: Using a `for...of` loop is generally preferred over from#each().
          This is mainly provided to ease things for legacy code, as pre-ES2015
          JavaScript doesn't support `for...of`.

from#first([predicate]);

    Runs the query, calling `predicate` for each result, and returns the first
    value that matches.  If `predicate` is omitted, the very first result is
    returned.

    Note: If there are no matching results, first() returns undefined.  This
          operation is short-circuiting: the first item that passes the check
          terminates the query.

from#from([selector]);

    Calls `selector` for each result and uses the contents of the returned
    object or array as the results of the operator.  This is used to expand a
    query into subcollections.  If no selector is provided, the results
    themselves are assumed to be query sources.

from#including(source[, ...]);

    Adds results from the specified source(s).  This is not the same as
    from#from(); while the latter expands a source per result, from#including()
    only does so once, after all other results have been processed.

from#last([predicate]);

    Runs the query, calling `predicate` for each result, and returns the last
    value that matches.  If `predicate` is omitted, the absolute last result is
    returned.

    Note: If there are no matching results, last() returns undefined.

from#random(count);

    Takes `count` random results and filters out the rest.  Note that this may
    sample a result more than once.  If you don't want duplicates, use
    from#sample() instead.

from#reduce([reducer[, initialValue]]);

    Runs the query and calls `reducer` for each result, assigning the result to
    an internal accumulator.  The current value of the accumulator is passed as
    the first argument to the reducer function, before the value and key.

    This is a pretty advanced operation, so to help illustrate, the following
    query calculates the sum of all numbers in the array `numbers`:

        sum = from(numbers).reduce((a, v) => a + v);

    Note: If `initialValue` is not given, the accumulator is initialized with
          the first query result; the reducer function will then not be called
          for that item.  If that behavior is not desirable, be sure to provide
          an initial value.

from#remove([predicate]);

    Removes results from the source object or array.  `predicate` is optional;
    if provided, it should return true to remove the result, or false to keep
    it.  If no predicate function is provided, all results are removed.

from#sample(count);

    Takes `count` random results and filters out the rest.  Unlike
    from#random(), this will not sample the same result more than once.

from#select(selector);

    Calls `selector` for each result, passing the return value on to subsequent
    operations.  This is used to transform results in the middle of a query,
    which can help code readability as well as avoid multiple requests for the
    same data.

from#shuffle();

    Shuffles the results.  Subsequent operators will see them in a random
    order.

from#skip(count);

    Filters out the first `count` results.  The rest are passed through as is.

from#take(count);

    Filters out all results after the first `count`.

from#toArray();

    Runs the query, assembling the final results into an array; returns the
    assembled array.

from#update(selector);

    Writes all results back into the source object or array.  `selector` is an
    optional mapping function to decide what value gets written back.  If no
    selector is provided, results are written as-is.

from#where(predicate);

    Calls `predicate` for each result.  The predicate function should return
    true to keep the result, or false to filter it out.  Only those results
    that match the predicate will be passed on.


`Console` Namespace
-------------------

The `Console` namespace provides a way to add a text-based debug console to
your game.  A full command parser is already built in, so the only thing your
game needs to do is provide names and implementations for supported console
commands.  Sphere will do the rest.

During gameplay, if the game has initialized the console, it can be shown and
hidden by the player using a hotkey (`~` by default).

    import { Console } from 'sphere-runtime';
    const Console = require('console');

Console.visible [read/write]

    Gets or sets whether the console is visible to the player.  Setting this to
    `true` will show the console, while setting to `false` will hide it.

Console.initialize(options);

    Initializes the console, enabling the player to access it while in-game.
    `options` can include any of the following properties:

        options.hotKey

            A `Key` value specifying which keyboard key will show and hide the
            console.  If not provided, defaults to `Key.Tilde`.

Console.defineObject(objectName, thisObj, commands);

    Registers an object and a set of commands with the console.  `commands` is
    an object providing the names and implementations of the commands being
    added, which will be associated with the name specified by `objectName`.
    Each property of `commands` has as its key the command name, and a function
    as its value, which will be called when the command is invoked.  `thisObj`
    specifies a `this` binding to use when calling a command function.

    As this API is complex and difficult to explain, an example might help
    illuminate things.  A sample term.define() call might look something like
    this:

        term.define('sound', null, {
            'play': function(filename) {
                if (fs.exists(filename)) {
                    new Sound(filename).play(Mixer.Default);
                }
            }
        });

    The player could then type `sound play sounds/munch.wav` into the console
    to play that sound (assuming it exists).  Note that if an error is thrown
    while processing a command, the console will not catch it.  Games should
    perform some form of error checking in their command functions to prevent
    the player from destabilizing the game.

Console.log(text[, text2[, ...]]);

    Logs a line of text to the console.  Passing more than one value will cause
    the strings to be separated with chevrons (`>>`).

Console.undefineObject(objectName);

    Unregisters all commands previously registered under `objectName`.  See
    `term.define()` for more information.  Note: It is not currently
    possible to unregister individual commands.


`DataReader` Object
-------------------

`DataReader` allows you to read from structured binary files like those used
for Sphere game assets (maps, tilesets, etc.) based on a simple JSON schema.
You can also read individual binary values from the file.

    import { DataReader } from 'sphere-runtime';
    const DataReader = require('dataReader');

new DataReader(stream, schema);

    Constructs a `DataReader` object which can be used to read binary data from
    a stream.  `stream` is an object with a `read()` method taking a byte count
    and returning an ArrayBuffer, such as a `FileStream` or `Socket`.

DataReader#readFloat32([littleEndian]);
DataReader#readFloat64([littleEndian]);

    Reads an IEEE floating point value from the associated stream.  If
    `littleEndian` is true, reads in little-endian mode.  Otherwise, reads in
    big-endian mode.

DataReader#readInt8();
DataReader#readInt16([littleEndian]);
DataReader#readInt32([littleEndian]);
DataReader#readUint8();
DataReader#readUint16([littleEndian]);
DataReader#readUint32([littleEndian]);

    Reads an integer value from the associated stream.  If `littleEndian` is
    true, reads in little-endian mode.  Otherwise, reads in big-endian mode.

    Note: "readUint" variants read unsigned values.  "readInt" variants read
          signed ("two's complement") values.

DataReader#readString(length);

    Reads a UTF-8 string from the associated stream.  `length` specifies how
    many bytes to read.

DataReader#readString8();
DataReader#readString16([littleEndian]);
DataReader#readString32([littleEndian]);

    Reads a UTF-8 length-prefixed string from the associated stream, where the
    length in bytes is stored as an unsigned integer.  If `littleEndian` is
    true, reads in little-endian mode.  Otherwise, reads in big-endian mode.

DataReader#readStruct(desc);

    Reads an object from the associated stream, based on `desc`.  The
    descriptor is an object describing the layout and typing of the data; for
    example, the following will read the 256-byte header from a Sphere v1
    format map file:

        rmp_header = myReader.readStruct({
            signature: { type: 'fstring', length: 4 },
            version: { type: 'uint16le' },
            type: { type: 'uint8' },
            numLayers: { type: 'uint8' },
            reserved1: { type: 'raw', size: 1 },
            numEntities: { type: 'uint16le' },
            startX: { type: 'uint16le' },
            startY: { type: 'uint16le' },
            startLayer: { type: 'uint8' },
            startDir: { type: 'uint8' },
            numStrings: { type: 'uint16le' },
            numZones: { type: 'uint16le' },
            repeating: { type: 'bool' },
            reserved2: { type: 'raw', size: 234 },
        });


`DataWriter` Object
-------------------

`DataWriter` allows you to write binary data to files or sockets.  It's like
`DataReader` (see above), but for write access.

    import { DataWriter } from 'sphere-runtime';
    const DataWriter = require('dataWriter');

new DataWriter(stream);

    Constructs a `DataWriter` object which can be used to write binary data
    into a stream.  `stream` is an object with a `write()` method that takes an
    ArrayBuffer, such as a `FileStream` or `Socket`.

DataWriter#writeFloat32(value[, littleEndian]);
DataWriter#writeFloat64(value[, littleEndian]);

    Writes a floating point value to the stream.  If `littleEndian` is true,
    writes in little-endian mode.  Otherwise writes in big-endian mode.

DataWriter#writeInt8(value);
DataWriter#writeInt16(value[, littleEndian]);
DataWriter#writeInt32(value[, littleEndian]);
DataWriter#writeUint8(value);
DataWriter#writeUint16(value[, littleEndian]);
DataWriter#writeUint32(value[, littleEndian]);

    Writes an integer value to the associated stream.  If `littleEndian` is
    true, writes in little-endian mode.  Otherwise writes in big-endian mode.

    Note: "writeUint" variants write unsigned values.  "writeInt" variants
          write signed ("two's complement") values.

DataWriter#writeString(value);

    Writes a UTF-8 string to the associated stream.

DataWriter#writeString8(value);
DataWriter#writeString16(value[, littleEndian]);
DataWriter#writeString32(value[, littleEndian]);

    Writes a UTF-8 length-prefixed string to the associated stream, where the
    length is stored as an unsigned integer.  If `littleEndian` is true, writes
    in little-endian mode.  Otherwise, writes in big-endian mode.


`Delegate` Object
-----------------

A simple multicast delegate implementation which works similarly to events in
.NET.  An object exposes one or more delegates, which can have handler
functions registered to them by outside code.  When something interesting
happens, the object owning the delegate invokes it, which calls all the
registered handlers in turn.  In this way outside code can react to changing
situations without breaking encapsulation.

    import { Delegate } from 'sphere-runtime';
    const Delegate = require('delegate');

new Delegate();

    Constructs a new delegate.  The delegate starts out empty, with no handlers
    attached.

Delegate#add(handler[, thisObj]);

    Registers the function `handler` with the delegate.  Whenever the delegate
    is invoked, all handlers registered at that time will be called in order.
    `thisObj` is optional and specifies an object to use for the `this` binding
    when calling `handler`.

    add() will throw an error if a matching handler has already been
    registered.

Delegate#call([...]);

    Calls all handlers registered with the delegate.  Calls are made in order
    of registration, and any arguments passed to `call()` are forwarded to the
    handlers as-is.

Delegate#remove(handler[, thisObj]);

    Removes a previously-registered handler from the delegate.  Throws an error
    if no matching handler is registered.


`Image` Object
--------------

When developing a sprite-based game, it's convenient to be able to draw images
on-the-fly in arbitrary locations.  With the Core API, drawing an image means
loading the image file, constructing a shape to texture with it, setting all
its coordinates (including texture coordinates), and possibly constructing a
model too.  Drawing the image in a different location means either recreating
the shape, or else manipulating the model's transformation matrix.

The `Image` object, part of the Sphere Runtime, handles all this for you,
letting you concentrate on setting up your scene without having to juggle
Shape, Model, and Transform objects.

    import { Image } from 'sphere-runtime';
    const Image = require('image');

new Image(fileName);

    Constructs an Image object from the specified image file.

    Note: `fileName` is relative to `@/images` unless it includes a SphereFS
          prefix.  The file extension is optional; if no extension is included,
          Sphere will find an appropriate file automatically.

Image#blitTo(surface, x, y[, tint_color);

    Draws the image as a textured quad at (x, y) on the specified surface.
    `tint_color`, if provided, specifies the color to combine with the image's
    pixels.  The default is `Color.White`, which leaves the image unchanged.


`Joypad` Namespace
------------------

The `Joypad` namespace provides a simplified interface for games that want to
support joystick input without the complexity of the Sphere v2 Joystick API.
Using this module, games can support joystick input for up to 4 players
simultaneously.

    import { Joypad } from 'sphere-runtime';
    const Joypad = require('joypad');

Joypad.P1 [read-only]
Joypad.P2 [read-only]
Joypad.P3 [read-only]
Joypad.P4 [read-only]

    Gets a Joystick object representing a connected device.  `Joypad.P1` always
    refers to the same device within a session; likewise for the other players.
    If no suitable device is available for the specified player,
    `Joystick.Null` is returned instead.

    Note: Only connected devices with at least 5 buttons and 2 axes are
          considered.


`Logger` Object
---------------

The `Logger` object provides basic logging functionality.  Your game can use
this to log lines of text to a file--complete with timestamps for each--which
is often very useful for debugging purposes.

    import { Logger } from 'sphere-runtime';
    const Logger = require('logger');

new Logger(filename);

    Opens the specified file for logging.  If the file cannot be opened for
    writing, an error is thrown.

    Note: `fileName` is relative to `~/logFiles` unless it includes a SphereFS
          prefix.  If it doesn't include a prefix, ".log" is appended to the
          filename automatically.

Logger#beginGroup(text);

    Begins an group.  All log entries in a group will be indented.  Groups can
    be nested.

Logger#endGroup();

    Closes the most recently opened group.  There should be a corresponding
    endGroup() for each beginGroup() call.

Logger#write(text);

    Writes a timestamped entry to the log.  `text` should contain no newline
    characters, although this is not enforced.


`Music` Namespace
-----------------

A flexible system based on Audialis for managing playback of background music.
The design, based on a pushdown stack, integrates well with finite state
machine architectures, which are often themselves based on a stack of states.
Code can push new BGM to the music stack, and when it is later popped, the
previous track resumes right where it left off.

The Music engine supports crossfading, which helps smooth out BGM transitions.
The music stack can also be bypassed when needed, from simply switching out the
song on top of the stack with another track, to overriding the contents of the
stack entirely, which is often useful in RPGs to override the battle music for
story reasons.

    import { Music } from 'sphere-runtime';
    const Music = require('music');

Music.adjusting [read-only]

    true if the music volume is currently being adjusted by a call to
    music.adjustVolume() (see below), otherwise false.

Music.adjustVolume(newVolume, time);

    Smoothly adjusts the BGM volume level.  `newVolume` should be a value
    between 0 and 1, where 0 is silent and 1 is full volume.  `time` is the
    amount of game time the adjustment should take, in frames.

Music.override(fileName[, fadeTime]);

    Overrides the BGM stack by playing the track specified by `fileName` at all
    times.  One example use is in RPGs, e.g. to override the battle music
    during an important storyline event.  `fadeTime` is the amount of crossfade
    to apply, in frames.

    Overriding the BGM doesn't prevent music stack tracking.  Once the override
    is cancelled (by calling `reset()`), the song on top of the stack at that
    time will resume playback.

    Note: `fileName` is relative to `@/music` unless it includes a SphereFS
          prefix.  The file extension is optional; if no extension is included,
          Sphere will find an appropriate file automatically.

Music.play(fileName[, fadeTime]);

    Replaces the song on top of the music stack with the track named by
    `fileName`.  This is not an override; if `play()` or `push()` is called
    afterwards, the BGM will change.  `fadeTime` is the amount of crossfade to
    apply, in frames.

    Note: `fileName` is relative to `@/music` unless it includes a SphereFS
          prefix.  The file extension is optional; if no extension is included,
          Sphere will find an appropriate file to play automatically.

Music.pop([fadeTime]);

    Pops the topmost song off the music stack.  This will resume playing
    whatever song was playing when the corresponding push() was done.

Music.push(fileName[, fadeTime]);

    Pushes a new song to the music stack.  If pop() is called later, the
    previous BGM will resume from where it left off.  `fadeTime` is the amount
    of crossfade to apply, in frames.

    Note: `fileName` is relative to `@/music` unless it includes a SphereFS
          prefix.  The file extension is optional; if no extension is included,
          Sphere will find an appropriate file to play automatically.

Music.reset([fadeTime]);

    Resets the BGM manager to normal operation, removing any outstanding
    overrides.  `fadeTime` is the amount of crossfade to apply, in frames.


`Prim` Namespace
----------------

The `Prim` namespace provides convenience functions for drawing common graphics
primitives such as circles and rectangles, which are tedious to render using
the Core API directly.

    import { Prim } from 'sphere-runtime';
    const Prim = require('prim');

Prim.blit(surface, x, y, texture[, mask]);

    Draws the specified texture as a plain image.  `mask` gets multiplied into
    each texel and has the effect of tinting the rendered image.  If no mask is
    specified, `Color.White` is assumed, which leaves the image as-is.

Prim.blitSection(surface, x, y, texture, sx, sy, width, height[, mask]);

    Like `Prim.blit()`, but allows drawing only part of a texture.  `sx`, `sy`,
    `width` and `height` specify the section to be drawn.

Prim.drawCircle(surface, x, y, radius, color);

    Draws the outline of a circle.

Prim.drawEllipse(surface, x, y, rx, ry, color);

    Like `Prim.drawCircle()`, but draws an ellipse instead.

Prim.drawLine(surface, x1, y1, x2, y2, thickness, color[, color2]);

    Draws a line segment of given thickness from (x1,y1) to (x2,y2).  If
    `color2` is provided, draws a gradient line.

Prim.drawPoint(suface, x, y, color);

    Draws a single pixel.

Prim.drawRectangle(surface, x, y, width, height, thickness, color);

    Draws the outline of a rectangle with given thickness.

Prim.drawSolidCircle(surface, x, y, radius, color[, color2]);

    Draws a solid circle.  If `color2` is given, draws a gradient circle where
    `color` is the color in the center and `color2` is the color at the edges
    of the circle.

Prim.drawSolidEllipse(surface, x, y, rx, ry, color[, color2]);

    Like `Prim.drawSolidCircle()`, but draws an ellipse instead.  `rx` is the
    horizontal radius and `ry` is the vertical radius.

Prim.drawSolidRectangle(surface, x, y, width, height, color_ul[, color_ur, color_lr, color_ll]);

    Draws a solid rectangle.  If four colors are given instead of one, draws a
    gradient rectangle with each corner a different color.  Colors are given in
    clockwise order starting from the upper left.

Prim.drawSolidTriangle(surface, x1, y1, x2, y2, x3, y3, color[, color2, color3]);

    Draws a solid triangle.  If three colors are given instead of one, draws a
    gradient triangle with each vertex a different color.

Prim.fill(surface, color);

    Fills a surface with a specified color.  In practice, this has the same
    effect as drawing a rectangle of the specified color over the entire
    surface.


`Random` Namespace
------------------

Many games don't need the full power of the Sphere `RNG` object and just need
a convenient way to generate random numbers for various purposes.  The `Random`
namespace provides exactly that.

    import { Random } from 'sphere-runtime';
    const Random = require('random');

Random.chance(odds);

    Returns true or false depending on the given odds.  `odds` is a number in
    the range [0-1] specifying the odds of returning true.  For example, odds
    of 0.75 will return true 75% of the time.

Random.discrete(min, max);

    Returns a random integer uniformly distributed within the range [min,max].

Random.normal(mean, sigma);

    Returns a random floating point number from a normal distribution
    (sometimes called a bell curve) with expected value of `mean` and standard
    deviation `sigma`.

Random.sample(array);

    Returns a randomly chosen item from the specified array.

Random.string(length);

    Returns a randomly generated string consisting of alphanumeric characters.
    The generated string looks something like a YouTube video hash (e.g.
    YlHRHDrKS) and is useful for uniquely identifying things, for example to
    generate temporary filenames.

Random.uniform(mean, variance);

    Returns a random floating point value uniformly distributed around `mean`
    with an absolute maximum deviation ("give or take") specified by
    `variance`.


`Scene` Object
--------------

The Scene object encapsulates a powerful scene engine which can run multiple
operations in parallel, and then sync the timelines up as needed.  An example
of this would be where several characters need to move into place for a
cutscene, but may take differing amounts of time to get there.  The game can
fork the timeline once for each character, and then resync on the main
timeline, which will wait until all the forked timelines finish before
continuing.

Scene is originally based on the Scenario standalone cutscene engine for
Sphere v1, but has been updated to take advantage of Sphere v2 features and to
integrate more seamlessly with other Sphere v2 technologies.

    import { Scene } from 'sphere-runtime';
    const Scene = require('scene');

A scene consists of a chain of scenelet invocations, with optional forks and
resync points.  For example, supposing the scenelets used have been properly
defined, the scene below would cause the screen to fade out simultaneously and
the person `scott` to walk offscreen, and finally change the background music
only when both are complete:

    var myScene = new Scene()
        .fork()  // fork the timeline
            .fadeTo(new Color(0, 0, 0, 255), 2.0)  // 2 sec. fade
        .end()
        .walkOffscreen("scott")
        .resync()  // resync point - await completion of forks
        .changeBGM('maggieIsHungry')

This scene can be played back at any time by calling `myScene.run()`.  miniRT's
scene engine uses the threads module and by default, scenes are nonblocking.
See the documentation for `Scene#run()` below to find out how to play a scene
in blocking mode.

Scene.defineAction(name, def);

    Registers a new action with the scene engine.  `name` is the name of the
    action and should be a valid JavaScript identifier (although this is not
    enforced).  `def` is an object defining the scenelet, and should include
    the following function properties:

        def.start(scene, ...)

            Required.  Called once when the scenelet begins execution.  .start()
            should initialize any execution state for the scenelet.  For one-off
            operations which can be completed entirely in the start function,
            .start() may return false.  Otherwise, it should return true to kick
            off a scenelet thread.

            .start() receives all arguments provided when the scenelet was added
            to the scene.

        def.update(scene)

            Required.  The scenelet's update function.  As with threads, this
            is called once per game frame and should return true to continue
            scenelet execution or false to finish.

        def.render(scene)

            Optional.  .render() is called once per render frame to render
            anything related to the scenelet.  A dialogue scenelet might render
            a textbox, for example.  Render order is determined by the order in
            which scenelets were started.

        def.getInput(scene)

            Optional.  Called once per game frame for the topmost scenelet to
            accept player input for that scenelet.  Only scenelets implementing
            a .getInput() callback are considered for topmost status.

    Each callback receives a reference to the Scene object which invoked it as
    its first argument, and its `this` binding is set to a unique object it can
    use to manage execution state for that invocation only.

new Scene();

    Constructs a new scene definition.  The scene starts with no scenelets and
    will do nothing when run.  Calling any method other than .run() on the scene
    will add scenelets, and this is how you build a scene.

Scene#isRunning();

    true if scene execution is in progress, false if not.

Scene#doIf(fn);

    `fn` should be a function.  Any scenelets between the doIf() and its
    corresponding end() will be executed only if the function returns true.
    This is like to an `if` statement in JavaScript.

Scene#doWhile(fn);

    `fn` should be a function.  Any scenelets between the doWhile() and its
    corresponding end() will be executed in a loop as long as the function
    keeps returning true.  This is like to a `while` statement in JavaScript.

Scene#end();

    A metascenelet which closes the open context.  Currently, metascenelets
    which open a context and therefore require an end() marker are:

        doIf()
        doWhile()
        fork()

Scene#fork();

    A metascenelet which forks the timeline.  This opens a new timeline to which
    all subsequent scenelets are added until an end() metascenelet is
    encountered.  Forked timelines run in parallel with the timeline that
    spawned them.

Scene#restart();

    Restarts a scene from the beginning, regardless of whether or not it was
    running at the time restart() is called.

Scene#resync();

    A metascenelet which adds a resync point to the open timeline.  Timelines
    may be forked to run operations in parallel, but it is sometimes necessary
    to wait until several simultaneous operations have completed before
    continuing.  Resync points do just that, halting the timeline they are found
    on until all outstanding forks against it have completed.

    There is an implicit resync point at the end of a timeline.  In practice,
    this means that a scene will not complete until all of its timelines have
    completed.

Scene#run([blocking]);

    Plays back this scene.  `blocking` is an optional boolean argument
    specifying whether to wait for the scene to finish before returning.  If not
    provided, the default is false.

Scene#stop();

    Stops scene execution immediately.  This works like the Stop button on a CD
    player: The next time the scene is run, it will start from the beginning.


`Test` Namespace
----------------

An implementation of the standard CommonJS testing module.  The primary use for
this namespace is to automate unit testing.  The `Test` namespace consists of a
single function.  Unit test code itself can likely benefit from the `assert`
function though; see above for more information about that one.

    import { Test } from 'sphere-runtime';
    const Test = require('test');

Test.run(tests);

    Runs all unit tests in `tests`.  `tests` is an object with a number of
    methods beginning with the word "test", e.g. testPig(), testCow(), etc.
    Each one will be called in turn, in Object.keys() order.

    Note: If you need a bit more organization, `tests` can also have subobjects
          beginning with the word "test".  Any test methods found in subobjects
          will be called as well.


`Thread` Namespace
------------------

An easy-to-use cooperative threading engine.  In Sphere v1, games could define
an update and render script, which would called each frame.  Using the `Thread`
object, multiple threads can be created, each with its own update and render
handler.  This allows many actions to run simultaneously.  For example, you
might have a thread to run the in-game clock and another to manage animations.
An active-time battle engine might even use several threads to manage each of
the units on the battlefield.

    import { Thread } from 'sphere-runtime';
    const Thread = require('thread');

Thread.create(def[, priority]);

    Creates a new thread and returns its thread ID (an integer).  `def` should
    be an object with the following properties:

        def.update()

            The thread's update function.  This is called once per game frame to
            update any state maintained by the thread.  The update function
            should return true to keep the thread going.  If it ever returns
            false, the thread will terminate.

        def.render()

            Optional.  The thread's render function.  This is called once per
            render frame to perform any rendering related to the thread.  For
            example, a thread managing a battle unit could render its sprite.
            Render order of threads is determined by `priority`, with higher
            priority threads being rendered later (closer to the screen).

        def.getInput()

            Optional.  Called once per frame to process player input for the
            thread.  In the current version of miniRT (2.0), getInput() and
            update() calls will always match 1:1.  Future versions may change
            this however, for example by implementing an input stack or
            Z-ordering of some form.

    Each of the above functions is called with its `this` binding set to `def`.
    This can be used to implement an "entity": a full object implementing the
    above functions which manages its own thread.

Thread.isRunning(tid);

    true if a thread with thread ID `tid` is running.  miniRT never recycles
    thread IDs, so this can be counted on to return false if given the tid of a
    thread which has terminated.

Thread.join(tid);

    Blocks the caller and awaits termination of the thread with thread ID `tid`.
    Any running threads (and the map engine, if it's in use) will continue to
    run.  If called during a thread update, the calling thread will be blocked
    from updating or accepting input until the join is satisfied.

    Note that due to limitations inherent to JavaScript's single-threaded
    architecture, join is implemented recursively and can only be satisfied in
    a last-in-first-out manner.  So if two threads are being awaited and the
    first one terminates, the corresponding join cannot be satisfied until the
    second thread also terminates.

Thread.kill(tid);

    Forcibly terminates the thread with thread ID `tid`.  If the thread ID is
    invalid or has already terminated, nothing happens.

Thread.self();

    When called from an update or render function, returns the thread ID of the
    active thread.  Otherwise, returns 0.


`XML` Namespace
---------------

The `XML` namespace provides functions to parse XML-formatted data and build a
document object model (DOM) from it.  This module is based on the MIT-licensed
"sax js" parser.  The API is simple but should cover most use cases.

    import { XML } from 'sphere-runtime';
    const XML = require('xml');

XML.parse(text);

    Parses XML text provided to the function and returns a DOM built from it.
    This function will throw if an error occurs during parsing, for example due
    to invalid or malformed XML.

    The DOM generated by this function is defined as follows:

        1. The DOM object has a property, `nodes`, which is an array of node
           objects.  Its `type` is set to "root".
        2. A node's `type` may be either "tag", "text", or "comment".
        3. A "tag" node represents an XML element and has its own `nodes`
           property, whose entries follow Rule 2 above.
        4. "text" and "comment" nodes are leaves.  They do not have a `nodes`
           property; instead they have a `text` string property with their
           content.

XML.readFile(fileName);

    Loads XML text from a file and returns a DOM built from it.

    Note: The return value and throw semantics of this function are identical
          to those of `XML.parse()` above.
