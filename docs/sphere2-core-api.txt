Sphere v2 Core API Reference
============================

As the official successor to the original Sphere engine, neoSphere implements
nearly the entire Sphere v1 API.  However, the v1 API is quite dated and, as of
miniSphere 4.0, has been deprecated in its entirety.  It is not documented here
at all; while games using the legacy functions will continue to run, new code
should be written against the modern Sphere v2 API, documented here.

In order to ease migration of existing Sphere v1 codebases to Sphere v2, legacy
and modern API calls may be freely intermingled within the same codebase, and
that holds true even when the engine is running in compatibility mode.

This document will, at various points, refer to both "Sphere" and "neoSphere".
Sphere refers to the platform as a whole, while neoSphere is specifically the
implementation of the engine for PC operating systems. The other major
implementation is Oozaru, for Web browsers, which is currently experimental.


The Sphere Event Loop
---------------------

Sphere, like most JavaScript-based platforms, is built around the concept of a
central event loop that keeps the engine running and schedules JavaScript
execution.  JavaScript operations cannot run indefinitely; the engine runs in
a single thread, so the game must yield to the event loop periodically to allow
other tasks to run.  There are two ways this can be done: either by allowing
the current operation to run to completion, or by suspending execution using
the `await` operator.

The event loop begins running after all JavaScript modules have been loaded and
remains active as long as there is something for it to do.  Each iteration of
the event loop constitutes one frame and consists of three phases:

    Render: The Render phase calls jobs set up with `Dispatch.onRender()`.
            This phase is unique in that it may be skipped entirely in order
            to maintain the game's desired frame rate.  Only drawing operations
            should be performed during this phase.  Immediately after the
            Render phase, the contents of the backbuffer are flipped to the
            screen and the backbuffer is cleared.

    Update: The Update phase calls jobs set up with `Dispatch.onUpdate()`.
            Updates are regulated by `Sphere.frameRate` (see below), which you
            can take advantage of to simplify, e.g., animation code.

    Dispatch: The Dispatch phase is a multi-purpose phase which calls one-off
              jobs such as `Dispatch.now()` and settles promises.  The Dispatch
              phase runs until there are no more jobs to execute, ensuring
              results which are available immediately aren't delayed until the
              next frame.


API Versioning
--------------

The Sphere API is constantly evolving, and as such new functions and classes
are added often.  When a new API feature is added, it will be designated as
experimental until the next API freeze.  At that time, the engine's supported
API level will be incremented and some of the experimental APIs will be
"canonized" under the new API level.  Once that happens, those APIs are said to
be frozen: no further breaking changes will be made to them.

The maximum supported API level in this version of neoSphere is level 4.

If a game uses only frozen APIs, it shouldn't be broken by upgrading to a newer
engine version; this is the true goal of an API freeze.  If the behavior of a
canonized function changes in a way that breaks existing game packages, this is
almost certainly a bug and should be reported.

Note that the backwards compatibility guarantees in Sphere are somewhat more
lenient in comparison to, say, the ECMAScript standard.  The goal is not to
break "typical" use cases; more exotic code that relies on, e.g., specific
property attributes may in fact be broken by an engine upgrade.  This provides
some breathing room when adding new features to existing APIs.  In particular,
upon upgrading the engine:

    1. A static namespace may become a class.  For example, under API 2,
       `BlendOp` is a namespace for predefined blending operators, but there is
       an experimental BlendOp constructor slated for canonization in API 3.
       Without this allowance, the constructor would need to be renamed.

    2. Accessor properties may become plain data properties, or vice versa.
       This is allowed because it can already happen at runtime; for example,
       `Font.Default` is cached as a plain value after the first access as an
       optimization to minimize the number of slow native calls.

    3. A read-only property may become read/write.  This is very unlikely to
       break even the most exotic use cases, and the alternative is to
       introduce an entirely new property, bloating the API unnecessarily.

    4. Existing functions may acquire new parameters.  If for some reason your
       code passes extra arguments to API functions assuming the excess will
       be discarded (through the spread operator `...`, for example, or when
       writing higher-order functions), such code may be broken by an engine
       upgrade.

    5. Functions that throw a TypeError or RangeError exception (or equivalent
       promise rejection) for a given input may acquire meaningful behavior for
       that input.  The error only indicates an unsupported request; your code
       shouldn't assume it will be unsupported forever!

The minimum API level required by a game is specified in its game manifest (see
above); if this value is not present, it defaults to level 1.  By default, all
API functions are available for use regardless of this value; however you can
start the engine using the `--retro` command line switch to have the engine
emulate the older API level, which disables all APIs introduced in a later
level as well as experimental features.

All class constructors, methods, properties, and manifest fields listed below
include the API level they were introduced in, e.g. `API 1` or else, for new
experimental features which haven't yet been canonized, `EXP`.


SphereFS File System
--------------------

Sphere uses the SphereFS standard to interpret file paths.  Under SphereFS,
when a relative path is used in an API call, it will be resolved relative to
the root of the game package (where `game.json` is located).  To load files
from a different location, you can use one of the SphereFS prefixes:

    @/: The root of the game's sandboxed file system.  Usually redundant, but
        can be useful to qualify filenames in situations where a bare SphereFS
        filename will be ambiguous, for example in an `import` declaration.
        This directory is read-only; trying to save or modify anything here
        will cause a TypeError to be thrown.
    $/: The directory containing the startup script.  This is mostly provided
        as a convenience for specifying module names in `import` declarations.
    #/: The engine's system directory.  This contains assets included with the
        engine.  As with `@/`, this is read-only to Sphere games.
    ~/: The current user's save data directory (note: requires a save ID; refer
        to the section on `game.json` above).  This is generally used to store
        save data and such where the user can easily access it.

As an example, the following call will read all text lines from the file named
`eaty-list.txt` in the user's save data directory:

    let thingsThatAreEaty = FS.readFile('~/eaty-list.txt', DataType.Lines);

Any attempts to circumvent the SphereFS sandbox using a relative path, e.g.
"@/../filename", will be met with a URIError exception.


JSON Game Manifest (`game.json`)
--------------------------------

To take full advantage of the Sphere v2 platform, a game package must include a
file named `game.json` in its root directory.  This file holds metadata such as
the title and author, as well as some control information which affects how the
engine runs the game.

Note that if your project has a Cellscript, Cell will generate this file for
you at build time based on the values you assign to `Sphere.Game`.

Here's a sample manifest:

    {
        "name": "Spectacles: Bruce's Story",
        "saveID": "fatCerberus.spectacles",
        "author": "Fat Cerberus",
        "summary": "Follow Scott Starcross in his quest to stop the Primus.",
        "main": "@/bin/main.mjs"
        "version": 2,
        "apiLevel": 3,
        "resolution": "320x240",
    }

JSON fields defined by the Sphere v2 specification are documented below.
Because the manifest format is JSON, as many additional fields may be added as
needed, and their values can be accessed at runtime through `Sphere.Game`.

"name" [REQUIRED] [API 1]

    The title of the game.  This field must be present; if it isn't, the
    manifest will be considered invalid and the game will not start.

"main" [REQUIRED] [API 1]

    The SphereFS path of the main JavaScript module (see below for more on
    SphereFS).  This is the script the engine will run when the game is
    started.  If no "main" field is present, the game will not start.

"apiLevel" {default: 1} [API 1]

    The minimum API level required to run the game.  This field is only valid
    if the `version` field (see below) is set to 2.  The current valid range
    for `apiLevel` is 1-4.

    While generally all API functions and classes are available to game code
    regardless of this setting, sometimes changes are made to the API that can
    break existing code; in those cases the engine will emulate the older
    behavior if `apiLevel` predates the breaking change.

"author" {default: none} [API 1]

    The name of the person or company who developed the game.

"fullScreen" {default: false} [API 1]

    The game's preferred fullscreen mode.  If the engine is started without
    passing either `--windowed` or `--fullscreen` on the command line, the
    value of this property will decide whether to start in fullscreen mode or
    not.

    Note: Fullscreen mode is completely disabled while a debugger is attached,
          to avoid interfering with breakpoints and exception handling.

"resolution" {default: 320x240} [API 1]

    The default screen resolution of the game, expressed as a string of the
    form "WxH", specifying the number of pixels across and down.  For example,
    720p resolution would be expressed as "1280x720".

    Note: The resolution can be changed at will at runtime by calling
          `Sphere.setResolution`.

"saveID" {default: none} [API 1]

    A string usually of the form "authorID.titleID" uniquely identifying the
    game for the purposes of save data management.

    Note: While providing a save ID is optional, one must be defined before a
          game can use its SphereFS save store (`~/`).  Legacy games using
          only an SGM manifest therefore can't take advantage of the save
          store.

"summary" {default: none} [API 1]

    A short summary of the game.  While there is no imposed length limit, it
    is recommended to keep this short (150 characters or less) with no line
    breaks.

"version" {default: 2} [API 1]

    The Sphere standards version the game was developed against.  If this is
    set to 2 (or is just not present) the game runs in Sphere v2 mode.  In
    Sphere v2 mode, the main script is run as ESM code and can use `import`.

    If this is set to 1, the game runs in Sphere 1.x compatibility mode.  In
    compatibility mode, the main module is executed as traditional JS code,
    and neoSphere calls the global `game()` function--if one is provided--to
    begin game execution.

    Note: Regardless of the version specified, both Sphere v1 and v2 APIs will
          be available for use by game code.  The standards version merely
          tells the engine how to load the main module.


`Sphere` Namespace
------------------

The `Sphere` namespace hosts functions and properties that allow the game to
communicate with the underlying Sphere platform.  The properties provide access
to the engine's name, version number, and API level, and there are several
methods for managing execution.

Sphere.Engine [get] [API 1]

    A string specifying the name and version number of the game engine.  The
    version number takes the form X.Y.Z, where X is the major version, Y is the
    minor version, and Z is the patch level.

Sphere.Version [get] [API 1]
Sphere.APILevel [get] [API 1]

    The Sphere API version and level supported by the engine, respectively.
    `Version` indicates which version of the Sphere API is supported (e.g., 2),
    while `APILevel` reflects the evolutionary stage.  Whenever new classes,
    methods, or properties are added to the Core API, the API level is
    increased.

Sphere.Compiler [get] [API 1]

    A string specifying the name and version number of the compiler or build
    tool used to make the game distribution.  If no compiler information is
    available for the current game, this evaluates to `undefined`.

Sphere.Game [get] [API 1]

    An object whose properties describe the currently running game.  Initially,
    this consists of everything in the JSON manifest, plus whatever fields are
    synthesized by the game engine.

    Note: Properties of `Sphere.Game` can be freely added, removed, or
          modified, and this will be visible to game code.  The engine itself
          won't see the changes, however.

Sphere.frameRate [get] [set] [API 1]

    Gets or sets the frame rate.  Set this to Infinity to disable the frame
    limiter.  The default is 60 FPS.

    The frame rate is used to regulate the event loop.  For example if this is
    set to 60 (the default), the event loop will perform 60 iterations per
    second, skipping renders as necessary to meet that goal.

Sphere.frameSkip [get] [set] [API 1]

    Gets or sets the maximum number of frames the engine is allowed to skip in
    order to maintain the desired frame rate.

Sphere.fullScreen [get] [set] [API 1]

    Gets or sets whether the engine is running in fullscreen mode.  Set this to
    `true` for fullscreen, or `false` for windowed.

    Note: If an SSj debugger instance is attached, the engine is forced into
          windowed mode and any change to the value of `screen.fullScreen` will
          be silently ignored.

Sphere.main [get] [API 1]

    Gets a reference to the game's main object, when the main module exports a
    constructor or class.  This object is created by the engine on startup by
    instantiating the exported class using `new`.

Sphere.abort(message); [API 1]

    Aborts execution.  This is effectively a forced crash: JavaScript execution
    will cease immediately, and the exception screen will be shown displaying
    `message`.

    Note: Sphere.abort() bypasses all exception handling mechanisms, including
          the debugger if it's attached.  Be sure you know what you're doing!

Sphere.now(); [API 1]

    Returns the number of frames (including skipped frames) processed by the
    engine since it started running.  To measure wall clock time instead, use
    `Date.now()`.

    Note: This value will wrap around to zero after around 4.3 billion frames.
          That typically isn't an issue: at 60 FPS, a game would need to run
          continuously for *over 2 years* before the timer would roll over.

Sphere.restart(); [API 1]

    Restarts the engine.  All in-flight Dispatch jobs are canceled so that once
    control returns to the event loop, the engine will initiate a restart.

    Note: This initiates an asynchronous shutdown.  The game will restart ONLY
          after control has returned to the event loop.  Note that dispatching
          new update or render jobs before then will cancel the request!

Sphere.setResolution(width, height); [API 1]

    Changes the game's resolution.  This determines the width and height of
    the backbuffer (see `Surface.Screen` below); higher resolutions allow you
    to render more detail.

    Note: This change is not persistent and lasts only until the engine is
          closed.

Sphere.shutDown(); [API 1]

    Shuts down the engine.  All in-flight Dispatch jobs are canceled so that
    once control returns to the event loop, the engine will close.

    Note: This initiates an asynchronous shutdown.  The engine will close ONLY
          after control has returned to the event loop.  Note that dispatching
          new update or render jobs before then will cancel the request!

Sphere.sleep(frames); [async] [API 1]

    Returns a promise that resolves after the specified number of frames have
    elapsed.  Can be used with `await`.  This is useful to delay execution of a
    function without blocking the event loop.


`BlendOp` Object
----------------

The `BlendOp` object represents a pixel blending operation.  The parameters
specified when the BlendOp is created determine how the colors of an object are
to be combined with the existing contents of a surface.  To use a BlendOp, you
simply assign it to the `blendOp` property of a surface before drawing to that
surface and it will be used for all subsequent drawing operations on that
surface until a different one is set.

For convenience, predefined BlendOp objects are provided in the API for the
most common blending operations, but you can easily make new ones if these
don't meet your needs.

BlendOp.Default [get] [API 2]

    The default blending mode.  If no blending operation is specified for a
    surface, it will use this mode.  This represents traditional alpha
    blending; the final rendered pixel is a weighted average of the source and
    destination pixels, based on the alpha value of the source pixel.

BlendOp.Add [get] [API 2]
BlendOp.Average [get] [API 2]
BlendOp.Multiply [get] [API 2]
BlendOp.Replace [get] [API 2]
BlendOp.Subtract [get] [API 2]

    Adds, averages, multiplies, replaces, and subtracts the source and
    destination pixel values, respectively.  These modes cover most common use
    cases, so the engine provides them for convenience.

new BlendOp(operator, sf, df[, alpha_op, sf_alpha, df_alpha]) [experimental]

    Constructs a new BlendOp which blends colors according to the given
    parameters.

    `operator` (and `alpha_op`) specify the mathematical operator used for
    blending and must be one of the following (all operators are applied to
    each color component individually):

        BlendType.Add

            Adds the source and destination pixels together.  This is the most
            common mode used for blending.

        BlendType.Subtract

            Subtracts the source pixel from the destination pixel.  One case
            where this can be be used to great effect is selectively "removing"
            color or light from a scene.

        BlendType.SubtractInverse

            Subtracts the destination pixel from the source pixel.  This is not
            as immediately useful, but can be used, for example, to
            "pre-texture" a surface before drawing other things on it.

    Before applying the blend type as above, the factors `sf` and `df` (and
    `sf_alpha` and `df_alpha`) are first multiplied with the respective source
    and destination components (RGB for color factors and A for alpha factors)
    and the final blend is calculated using the modified values.  Each factor
    can be one of the following:

        Blend.Alpha
        Blend.AlphaInverse
        Blend.One
        Blend.Source
        Blend.SourceInverse
        Blend.Target
        Blend.TargetInverse
        Blend.Zero

    If `alpha_op` and its associated factors are not provided, the alpha
    channel will use the same blending type and factors as specified for the
    color channels.

    Note: Color components are assumed to be in the range [0.0, 1.0].  Blending
          may not work as expected for pixels with values outside this range.


`Color` Object
--------------

The `Color` object represents an RGB color value.  It also has an alpha
component and can therefore represent translucent colors.

Color.Red [get] [API 1]
Color.Green [get] [API 1]
Color.Blue [get] [API 1]
Color.Transparent [get] [API 1]
etc...

    Gets a copy of a predefined color.  The entire X11 color set is provided,
    giving you access to such colors as `DodgerBlue` and `Chartreuse` in
    addition to the standard red, green, blue, yellow, etc.

    Each of these is an accessor which returns a new Color object every time
    it is invoked.  This ensures that code like what's shown below won't cause
    undesirable side effects:

        let customColor = Color.Red;
        customColor.b = 255;  // we needed magenta instead

    The downside to this is that e.g. `Color.Red === Color.Red` evaluates to
    false, but this is rarely an issue in practice.

Color.fromRGBA(r, g, b[, alpha]); [experimental]

    Constructs a Color corresponding to the specified 8-bit RGBA values.
    Values range 0-255; the function will throw an error if passed a value
    outside this range.  If `alpha` (opacity) is not provided, it defaults to
    255.

Color.is(color1, color2); [API 1]

    Returns true if `color1` refers to the same physical color as `color2`
    without regard to their alpha components.  Otherwise returns false.

    Note: This is not the same as comparing the color objects' .name properties
          because Color#name encodes the alpha channel in addition to the
          physical color.

Color.mix(color1, color2[, w1, w2]); [API 1]

    Calculates a weighted average of two colors.  `w1` and `w2` are optional
    and specify the relative weights of `color1` and `color2` respectively.  If
    the weights are omitted, the mix is 50/50.

Color.of(name); [API 1]

    Returns a Color object from `name`, which can either be the name of a
    predefined X11 color without spaces (e.g. "chartreuse"), or an ARGB
    signature such as "#800000FF".  If `name` cannot be resolved to a color,
    throws a TypeError.

new Color(red, green, blue[, alpha]); [API 1]

    Constructs a new Color object.  Color objects are used to specify the color
    of elements such as vertices and primitives.  Color components should be in
    the range [0.0, 1.0]; out-of-range values are silently clamped.  `alpha`
    specifies the color's opacity and defaults to 1.0 if not provided.

Color#r [get] [set] [API 1]
Color#g [get] [set] [API 1]
Color#b [get] [set] [API 1]
Color#a [get] [set] [API 1]

    Gets or sets the individual components of the color (red, green, blue, or
    alpha).  Range is [0.0,1.0]; while values outside this range are accepted,
    HDR is not supported and the engine will automatically clamp such colors
    when rendered.

Color#name [get] [API 1]

    Gets the name of the Color according to its component values such that
    Color.of(color.name) will give back a Color with the same values.  Useful
    for saving and reading back colors from save files.

Color#clone(); [API 1]

    Returns a copy of this Color object.  Changes to the clone will not affect
    the original object.

Color#fadeTo(alpha_factor); [API 1]

    Scales this color's alpha channel by `alpha_factor`, between 0.0 and 1.0,
    and returns the result.  The red, green, and blue components are not
    modified.  One use for this is when you need to make a predefined color
    translucent; for example:

        let translucentBlue = Color.Blue.fadeTo(0.5);


`DirectoryStream` Object
------------------------

The `DirectoryStream` object allows you to read the contents of a directory.
This works a lot like reading data from a `FileStream` (see below) in that you
read file and directory entries one at a time.  `DirectoryStream` also
implements the JavaScript ES6 iterator protocol, so you can use it in a
query or `for...of` loop.

new DirectoryStream(dir_name[, options]); [API 1]

    Constructs a new DirectoryStream which reads entries from `dir_name`.  If
    the directory named by `dir_name` doesn't exist, throws an error.

    options.recursive [default: false] [experimental]

        If `recursive` is true, the DirectoryStream will descend into
        subdirectories to list files they contain.  The output will not contain
        any directory entries in this case, only file entries.

DirectoryStream#fileCount [get] [API 1]

    Gets the number of entries (both files and directories) in the directory
    listing.

DirectoryStream#fileName [get] [API 1]

    Gets the full SphereFS pathname of the directory whose entries are being
    enumerated.

    Note: Under SphereFS canonicalization rules, the pathname of a directory
          always ends in a slash (`/`).

DirectoryStream#position [get] [set] [API 1]

    Gets or sets the position within the stream.  This is an index into the
    directory specifying which entry will be read next.

DirectoryStream#dispose(); [API 1]

    Disposes of the DirectoryStream object, closing the underlying directory.
    Attempting to use the object afterwards will throw an error.

    Note: While it's not strictly necessary to call `dispose()` on stream
          objects,  it may take some time for the garbage collector to get to
          them.  If there's an active DirectoryStream for a given directory, an
          error may be thrown if you try to construct another one.

DirectoryStream#next(); [API 1]

    Reads the next entry from the directory and advances the stream position.
    This returns an object.  If there are no entries remaining, the object's
    `done` property is set to `true`; otherwise, `done` is `false` and `value`
    is an object with the following properties:

        value.isDirectory

            `true` if the entry is for a subdirectory, otherwise `false`.

        value.fileName

            The file or directory name of the entry.  Directory names will end
            in a slash (`/`).  For streams in recursive mode, `.fileName` can
            include relative path information, e.g., `subdir/file.ext`.

        value.fullPath

            The full SphereFS pathname of the entry.  As with `value.fileName`,
            directory paths end in a slash (`/`) per SphereFS canonicalization
            rules.

		value.depth [experimental]

		    The subdirectory nesting level of the entry, relative to the
		    directory being streamed.  This is equal to the number of nested
		    subdirectories which must be entered to find this entry.

		value.extension [experimental]

		    The filename extension (everything starting from the last dot `.`),
		    for file entries.  If the file has no extension, this is `null`.

		    This property is not present for directory entries.

    Note: This method is compatible with the JavaScript ES6 iterator protocol,
          allowing you to use the DirectoryStream as input to a query.  Refer
          to the Sphere Runtime API Reference for more information about
          queries.

DirectoryStream#rewind(); [API 1]

    Rewinds the stream and resets the position to 0.  If the directory contents
    have changed, rewinding the DirectoryStream will allow you to enumerate the
    new entries without creating a new stream.


`Dispatch` Namespace
--------------------

The Dispatch API is used to set up asynchronous function calls which are later
performed from a designated part of the Sphere event loop.  This is like an
advanced version of Sphere v1's update and render scripts, but more tightly
integrated and available throughout the engine.

When queueing a job, a token is returned which allows you to manage the
in-flight job.  See the documentation for `JobToken` below to find out what you
can do with the token.

Dispatch.cancelAll(); [API 1]

    Cancels all one-time jobs (except `onExit`) in the job queue.  In order to
    prevent mishaps, this does not cancel update, render and exit jobs.  Those
    must be cancelled individually.

Dispatch.later(num_frames, callback); [API 1]

    Sets up a one-time job to call `callback` from the event loop after
    `num_frames` frames have passed.

    Returns a `JobToken` you can use the manage the job.

Dispatch.now(callback); [API 1]

    Sets up a one-time job to call `callback` from the event loop during the
    current frame.  This is useful for performing operations that need to be
    done from the event loop with minimal delay.

    Returns a `JobToken` you can use to manage the job.

    Note: Dispatch.now(fn) is *NOT* an alias for Dispatch.later(0, fn).  The
          latter runs at the beginning of the next frame; Dispatch.now() jobs
          always run during the same frame they were issued.

Dispatch.onExit(callback); [experimental]

    Sets up a one-time job to call `callback` after the event loop exits.  This
    is useful when you need to ensure something always runs before the engine
    terminates; for example, automatically saving the game or finalizing a log
    file.

    Returns a `JobToken` you can use to manage the job.

    Note: Try not to do anything too intensive in an `onExit()` job if you can
          avoid it; the engine won't close until all exit jobs have finished
          running, so excessive delays here are likely to frustrate the user.

Dispatch.onRender(fn[, options]); [API 1]
Dispatch.onUpdate(fn[, options]); [API 1]

    Sets up a recurring job to call `fn` during a specified event loop phase.
    For example, `onRender()` jobs are called before the backbuffer is flipped,
    and `onUpdate()` jobs are called at the start of each frame.

    Returns a `JobToken` you can use to manage the job.

    Note: If you pass an `async` function to one of these and it takes multiple
          frames to complete, the engine will await completion of the previous
          invocation before invoking it again.  Avoid using `await` in a render
          handler as the function will resume at the end of a frame, after the
          backbuffer has already been flipped.

    options.inBackground [default: false]

        If this is `true`, the job won't keep the event loop alive.  This is
        useful for screen overlays and the like that you want to run in the
        background without preventing the game from exiting.

    options.priority [default: 0.0]

        Determines the order of calls when there is more than one job.  Render
        jobs are performed in ascending priority order, while update jobs are
        performed in descending priority order.  The priority can be negative,
        and fractional priorities are honored: 8.12, for example, is considered
        a higher priority than 8.0.


`FS` Namespace
--------------

The `FS` namespace allows your game to access asset and save files, create or
remove directories, etc.  All file system operations are sandboxed to prevent
damage to the system.

FS.createDirectory(pathname); [API 1]

    Creates a directory and any of its parent directories that don't already
    exist.  If the directory already exists, this function does nothing.

    Note: `FS.createDirectory()` is safe to call even if the directory to be
          created already exists.  This allows you to use it to ensure a
          directory exists before you access it, without needing an explicit
          check beforehand.

FS.deleteFile(pathname); [API 1]

    Deletes the file named by `pathname` from the file system.

FS.directoryExists(pathname); [API 1]

    Checks whether a directory by the name of `pathname` exists and returns
    `true` if it exists, or `false` otherwise.

FS.directoryOf(pathname); [API 2]

    Returns the full SphereFS path of the directory containing `pathname`.  The
    pathname is resolved via the usual SphereFS rules, so if no directory info
    is present, this function will return "@/".  If `pathname` ends in a
    forward slash `/`, then it names a directory and the function will simply
    return its canonical path.

    Note: If `pathname` doesn't end in a forward slash `/` but names a known
          existing directory, the function will act as if the trailing slash
          was present.

FS.evaluateScript(pathname); [API 1]

    Executes the JavaScript file named by `pathname` in the global scope and
    returns the result.  This is useful for executing scripts originally
    written for the Web, where modules are not supported.

    Note: Depending on the particular script being evaluated, this function
          can--and likely will--create new global functions and variables.  Be
          sure you know what you're doing!

FS.extensionOf(pathname); [API 2]

    If `pathname` refers to a file, returns the filename extension of the named
    file (i.e. everything starting from the last dot `.` in the filename).  If
    the file has no filename extension, returns `null`.

    Note: If `pathname` ends in a forward slash `/` or names a known existing
          directory, a TypeError will be thrown.

FS.fileExists(pathname); [API 1]

    Checks whether a file by the name of `pathname` exists and returns `true`
    if it exists, or `false` otherwise.

FS.fileNameOf(pathname); [API 2]

    If `pathname` is a full or partial path to a file, returns only the
    filename portion, or `undefined` if there is no filename in the path (for
    example, because it ends in a forward slash `/` and therefore refers to a
    directory).

    Note: If `pathname` doesn't end in a forward slash `/` but names a known
          existing directory, the function will act as if the trailing slash
          was present and return `undefined`.

FS.fullPath(pathname[, base_dir]); [API 1]

    Resolves `pathname` (which may contain relative path components, or even be
    relative itself) to a fully canonicalized SphereFS pathname.  `base_dir`
    is optional and specifies a base directory for relative paths.  The file or
    directory ultimately referred to doesn't need to exist.

    If `pathname` begins with a SphereFS prefix, it's resolved normally,
    without regard to `base_dir`.  Otherwise, `pathname` is considered to be
    relative to `base_dir`.

    Note: If `pathname` refers to a known existing directory, the path string
          returned by this function will end in a forward slash (`/`) even if
          the input pathname did not.

FS.match(pathname, pattern); [experimental]

    Determines whether `pathname` matches the pattern string(s) given by
    `pattern`.  `pattern` can be either a single pattern, or an array of them.
    Returns `true` if any of the patterns match, otherwise `false`.

    Note: Both `pathname` and `pattern` are SphereFS canonicalized before
          performing the check.  This means that a pattern such as `*.fat` will
          be treated as though it were `@/*.fat` and matched against the
          canonicalized pathname.

FS.readFile(pathname[, data_type]); [API 1]

    Reads an entire file at once and returns the content.  The optional
    parameter `data_type` specifies how interpret the file contents and can be
    one of the following (defaults to `DataType.Text`):

        DataType.Bytes

            Interpret the file as a sequence of bytes.  Sphere assigns no
            specific meaning to the individual bytes; that's up to your game's
            code.  Returns a Uint8Array.

        DataType.JSON

            Interpret the file as UTF-8-encoded JSON data.  Returns the result
            of running `JSON.parse()` on the contents of the file.  Requires
            API level 4 or higher.

        DataType.Lines

            Interpret the file as plain text (UTF-8).  Returns an array of
            strings, one for each line of text in the file.

        DataType.Raw

            Read the file back-to-front without attempting to interpret the
            data.  Returns an ArrayBuffer.

        DataType.Text

            Interpret the file as plain text (UTF-8).  This is the default.
            Returns a string representing the entire text content of the file,
            including newline characters.

    Note: `DataType` is supported only when running under API level 2 or
          higher.

FS.relativePath(pathname, base_dir); [API 1]

    Abbreviates a full SphereFS pathname, returning a string representing its
    path relative to `base_dir`.  This can be useful when logging filenames or
    displaying track names, for example.

FS.removeDirectory(pathname); [API 1]

    Removes the directory named by `pathname` from the file system.  If the
    directory doesn't exist--or *does* exist but is not empty (this function
    will not delete a non-empty directory)--an error will be thrown.

FS.rename(orig_name, new_name); [API 1]

    Renames the file named by `orig_name` to `new_name`, both of which are
    assumed to be full paths.  This can also be used to move a file between
    directories; if so, the destination directory must already exist.

FS.writeFile(pathname, data); [API 1]

    Writes `data`, which can be either a string, array of strings, ArrayBuffer,
    or TypedArray, to a file.  If a file already exists by the specified name,
    it will be overwritten.


`File` Object
-------------

Introduced with API level 4 for cross-compatibility with Oozaru, these
functions allow working with files asynchronously.  All of these functions
return promises which resolve only once the operation has completed.  This
allows the engine to load files, which may have to be downloaded from the Web,
in the background without blocking other operations.

async File.exists(pathname); [experimental]

    Starts checking if the file named by `pathname` exists and returns a
    promise that resolves to `true` if it does, or `false` otherwise.

async File.load(pathname[, data_type]); [experimental]

    Starts loading a file into memory and returns a promise for the full
    contents of the file.  The optional parameter `data_type` specifies what
    kind of data the file contains and can be one of the following:

        DataType.Bytes

            Interpret the file as a sequence of bytes.  Sphere assigns no
            specific meaning to the individual bytes; that's up to your game's
            code.  The promise resolves to a Uint8Array containing the raw
            data stored in the file.

        DataType.JSON

            Interpret the file as UTF-8-encoded JSON data.  The promise
            resolves to the result of running `JSON.parse()` on the contents of
            the file.  If the file is not valid JSON, the promise is rejected
            instead.

        DataType.Lines

            Interpret the file as plain text (UTF-8).  The promise resolves to
            an array of strings: one string for each line of text in the file.

        DataType.Raw

            Don't attempt to interpret the content of the file at all.  The
            promise resolves to an ArrayBuffer containing the raw data stored
            in the file.

        DataType.Text (default)

            Interpret the file as plain text (UTF-8).  The promise resolves to
            a string containing the entire text content of the file, including
            end-of-line characters.

async File.remove(pathname); [experimental]

    Deletes the file named by `pathname`.  The promise resolves once the file
    has been removed from the file system.  If the file to be deleted doesn't
    exist, this call still completes successfully.

async File.rename(pathname, new_name); [experimental]

    Starts renaming the file named by `pathname` to `new_name` and returns a
    promise that resolves once the renaming operating has finished.  Note that
    the promise rejects if the file to be renamed doesn't exist.

async File.run(pathname); [experimental]

    Loads the JavaScript file named by `pathname` and executes it in the global
    scope.  Returns a promise which resolves with the result of evaluating the
    script.  This can be useful for executing older scripts that were written
    before `import` was introduced.

    Note: Depending on the script being evaluated, this function can--and
          likely will--create new global functions and variables.  Be sure you
          know what you're doing!

async File.save(pathname, data); [experimental]

    Saves `data`, which can be either a string, array of strings, ArrayBuffer,
    or TypedArray, to the file named by `pathname`.  The promise resolves once
    the file has been fully written.

    Note: If a file already exists by the given name, its contents will be
          completely overwritten with the new data.


`FileStream` Object
-------------------

The `FileStream` object provides a low-level interface for reading and writing
any kind of file.  This can be used, for example, to support additional file
formats that aren't directly supported by the engine.  Sphere makes no attempt
to interpret the data in the file and simply provides access to the raw bytes
it contains.

FileStream.fromFile(filename, file_op); [async] [API 3]

    Opens a file asynchronously and returns a promise for a `FileStream` that
    provides access to the contents of the file.  `file_op` specifies the file
    operation requested and must be one of the following:

        FileOp.Read

            Read data from the file.  The file must exist and will be opened in
            read-only mode.  Any attempt to write to the file will throw a
            TypeError.

        FileOp.Write

            Write data to the file.  Be careful: If the file already exists,
            its contents will be overwritten.  If that behavior is not desired,
            use `FileOp.Update` instead.

        FileOp.Update

            Amend the file.  If a file by the specified name doesn't exist, it
            will be created.  For convenience, the file pointer is initially
            placed at the end of the file.

    Requesting write access to a file residing in a read-only directory (e.g.,
    the system directory `#/`) will reject the promise with a TypeError.

new FileStream(filename, file_op); [API 1]

    Similar to `FileStream.fromFile`, but opens the file synchronously, without
    interrupting the calling function, and returns the new object directly.

    Note: This call is not supported when targeting API 4 or higher. Use
          `FileStream.fromFile()` instead.

FileStream#fileName [get] [API 1]

    Gets the full SphereFS pathname of the underlying file.

FileStream#fileSize [get] [API 1]

    Gets the size of the underlying file, in bytes.

FileStream#position [get] [set] [API 1]

    Gets or sets the file position, which determines where in the file the next
    read or write will start from.  Expressed in bytes.

    Note: For files opened for writing, it is valid to seek past the end of the
          stream.  In this case the next write will be at the new position and
          the intervening space filled with NUL bytes.

FileStream#asyncRead(num_bytes); [async] [API 3]

    Instructs Sphere to read `num_bytes` from the file via the event loop.  The
    promise resolves with an ArrayBuffer containing the data read.  This is an
    asynchronous version of `read()` that can be used with `await`.

FileStream#asyncWrite(data); [async] [API 3]

    Instructs Sphere to write `data`--either an ArrayBuffer, TypedArray view,
    or DataView--to the file via the event loop.  The promise resolves once all
    bytes have been written out.  This is an asynchronous version of `write()`
    that can be used with `await`.

FileStream#dispose(); [API 1]

    Closes the file, performing any final processing as necessary.  Attempting
    to use the FileStream after calling this will cause an exception.

    Note: While it's not absolutely necessary to call `dispose()` on FileStream
          objects,  it may take some time for the garbage collector to get to
          them.  If there's an active FileStream for a given file, particularly
          if the file is opened in write mode, an error may be thrown if you
          try to construct another FileStream for the same file.

FileStream#read(num_bytes); [API 1]

    Reads data from the file, up to the specified number of bytes, and returns
    an ArrayBuffer containing the data read.  The file must be opened for
    reading.

    Note: This call is not supported when targeting API 4 or higher. Use
          `FileStream#asyncRead()` instead.

FileStream#write(data); [API 1]

    Writes data to the file and advances the file pointer.  `data` should be an
    ArrayBuffer, TypedArray or DataView containing the data to be written.

    Note: This call is not supported when targeting API 4 or higher. Use
          `FileStream#asyncWrite()` instead.


`Font` Object
-------------

The `Font` object specifies a typeface that can be used when drawing text.
Sphere provides a default font which is the same for all games, or you can load
one from an RFN font file.

Font.Default [get] [API 1]

    Gets the engine's default font.  This is the font used for the FPS counter
    and system messages.

Font.fromFile(filename[, size]); [async] [API 3]

    Loads the font file named by `filename` asynchronously and returns a
    promise for the newly constructed `Font` object. `size` specifies the font
    size in pixels for TrueType fonts; the size is ignored when loading RFN
    fonts.

new Font(filename[, size]); [API 1]

    Loads the font file named by `filename` synchronously, without yielding to
    the event loop, and returns the newly constructed Font object.  `size`
    specifies the font size in pixels for TrueType fonts; the size is ignored
    when loading RFN fonts.

    Note: This call is not supported when targeting API 4 or higher. Use
          `Font.fromFile()` instead.

Font#fileName [get] [API 1]

    Gets the full SphereFS pathname of the file used to construct this Font
    object.

Font#height [get] [API 1]

    Gets the line height, in pixels, for text rendered using this font.

Font#drawText(surface, x, y, text[, color[, wrap_width]]); [API 1]

    Renders `text` to the specified surface at (x,y).  `color` defaults to
    Color.White if not provided, and `wrap_width` specifies the width in which
    to constrain the text.  If `wrap_width` is not provided, no wrapping is
    performed.

Font#getTextSize(text[, wrap_width]); [API 1]

    Gets the size, in pixels, of `text` if it were rendered by Font:drawText()
    with the specified wrap width.  Return value is an object with `width` and
    `height` properties.

    Note: If `wrap_width` is not provided, no word wrap processing will be
          performed.

Font#heightOf(text[, wrap_width]); [API 2]

    Returns the height, in pixels, of `text` when rendered by `Font#drawText`
    using the specifed wrap width.  If `wrap_width` is not specified, returns
    the same value as `Font#height`.

Font#widthOf(text); [API 2]

    Returns the width, in pixels, of `text` when rendered by `Font#drawText`
    without wrapping.

Font#wordWrap(text, wrap_width); [API 1]

    Wraps `text` as if it were drawn with Font#drawText() using the specified
    wrap width.  Returns an array of strings, representing the lines in the
    wrapped text.

    When drawing large amounts of word-wrapped text every frame, for example in
    a text box, this function should be used to pre-wrap the text since
    performing wrapping calculations every frame can get expensive.


`IndexList` Object
------------------

An `IndexList` contains indices into a vertex list which are stored on the GPU
for fast access at render time.  Index lists can be useful if you want to store
all the vertices for a scene in a single `VertexList` and construct different
shapes from it.  The index list specifies which vertices from the list to use
to create a shape.

new IndexList(indices); [API 1]

    Constructs a new index list from `indices`, an array of integers in the
    range [0, 65535].  If `indices` is not an array or any element is not a
    number in the above range, an error will be thrown.

    Note: The list of indices stored on the GPU can't be modified later.  If
          you want to upload a new set of indices, you must construct a new
          `IndexList`.


`JobToken` Object
-----------------

A JobToken represents a job queued using one of the `Dispatch` functions above.
When queuing a job, you must keep a reference to the token if you want to be
able to manage the job later.

JobToken#cancel(); [API 1]

    Cancels the dispatch job associated with this token.  If the job was queued
    using either `Dispatch.now()` or `Dispatch.later()` and has already started
    running, calling this has no effect.

JobToken#pause(); [API 3]

    Pauses the job.  Paused jobs will not run, but do keep the event loop alive
    and can be resumed at any time without the need to dispatch a new job.

JobToken#resume(); [API 3]

    Resumes the job associated with this token after it's been paused with
    JobToken#pause().  If the job is not currently paused, this does nothing.


`Joystick` Object
-----------------

Joystick.Null [get] [API 1]

    Gets the null joystick.  When polled, a null joystick returns neutral
    values for all inputs.  Joystick.Null can be used in place of a real
    Joystick object to simplify input code.

Joystick.P1 [get] [API 2]
Joystick.P2 [get] [API 2]
Joystick.P3 [get] [API 2]
Joystick.P4 [get] [API 2]

   Gets the default joystick for the respective player.  If there are many
   joystick or gamepad devices attached, there is no guarantee which ones these
   will use, and the mapping could even change between sessions.  If you need
   full control, use `Joystick.getDevices` (see below).

   Note: If there are less than 4 devices attached, the unmapped objects will
         act like `Joystick.Null` and return neutral values for all inputs.

Joystick.getDevices(); [API 1]

    Gets an array of Joystick objects, one for each connected gamepad or
    joystick.  neoSphere currently supports a maximum of 16 attached devices;
    this will never return more than that.

Joystick#name [get] [API 1]

    Gets the name of the device, as reported by the operating system.  Xbox
    controllers, for example, are typically reported as "XInput Joystick <n>".

Joystick#numAxes [get] [API 1]

    Gets the number of analog axes supported by the device.

Joystick#numButtons [get] [API 1]

    Gets the number of buttons supported by the device.

Joystick#getPosition(axisID); [API 1]

    Polls the device and gets the current position along the specified analog
    axis.  To get the number of axes supported by a device, use the `numAxes`
    property.

    Note: Axes are numbered sequentially, starting from 0.  Which physical axis
          is associated with any given axis ID will vary from device to device.
          For gamepads with analog sticks, though, it's generally a safe bet
          that the primary analog stick will be mapped to the first two axes.

Joystick#isPressed(buttonID); [API 1]

    Polls the device and returns true if the specified button is currently
    depressed.  To get the number of buttons supported by a device, use the
    `numButtons` property.

    Note: Buttons are numbered sequentially, starting from 0.  As with axes,
          which physical button is associated with any given button ID will
          vary from device to device.


`Keyboard` Object
-----------------

What would a game be without the ability for the player to control it?  The
`Keyboard` object allows your game to accept input via the keyboard, the most
common input method for a PC game.

Key [enumeration] [API 1]

    Specifies a keyboard key.  Can be one of the following:

        Key.Alt
        Key.AltGr
        Key.Apostrophe
        Key.Backslash
        Key.Backspace
        Key.CapsLock
        Key.CloseBrace
        Key.Comma
        Key.Delete
        Key.Down
        Key.End
        Key.Enter
        Key.Equals
        Key.Escape
        Key.F1
        Key.F2
        Key.F3
        Key.F4
        Key.F5
        Key.F6
        Key.F7
        Key.F8
        Key.F9
        Key.F10
        Key.F11
        Key.F12
        Key.Home
        Key.Hyphen
        Key.Insert
        Key.LCtrl
        Key.LShift
        Key.Left
        Key.NumLock
        Key.OpenBrace
        Key.PageDown
        Key.PageUp
        Key.Period
        Key.RCtrl
        Key.RShift
        Key.Right
        Key.ScrollLock
        Key.Semicolon
        Key.Slash
        Key.Space
        Key.Tab
        Key.Tilde
        Key.Up
        Key.A
        Key.B
        Key.C
        Key.D
        Key.E
        Key.F
        Key.G
        Key.H
        Key.I
        Key.J
        Key.K
        Key.L
        Key.M
        Key.N
        Key.O
        Key.P
        Key.Q
        Key.R
        Key.S
        Key.T
        Key.U
        Key.V
        Key.W
        Key.X
        Key.Y
        Key.Z
        Key.D1
        Key.D2
        Key.D3
        Key.D4
        Key.D5
        Key.D6
        Key.D7
        Key.D8
        Key.D9
        Key.D0
        Key.NumPad1
        Key.NumPad2
        Key.NumPad3
        Key.NumPad4
        Key.NumPad5
        Key.NumPad6
        Key.NumPad7
        Key.NumPad8
        Key.NumPad9
        Key.NumPad0
        Key.NumPadEnter
        Key.Add
        Key.Decimal
        Key.Divide
        Key.Multiply
        Key.Subtract

    Note: Keys D0-D9 refer to the row of numbers above the letter keys and
          below the function keys, while NumPad0-NumPad9 refer to the numbers
          on the numeric keypad.

Keyboard.Default [get] [API 1]

    Gets a `Keyboard` object for the default keyboard device.

    Note: neoSphere currently only supports a single keyboard.

Keyboard#capsLock [get] [API 1]
Keyboard#numLock [get] [API 1]
Keyboard#scrollLock [get] [API 1]

    Gets the state of the corresponding lock key.  true if the lock is on,
    false if not.

Keyboard#charOf(key[, shifted]); [API 1]

    Gets the character(s) that would be generated if a specified key is pressed
    on this keyboard.  For example, Key.A becomes "a" (or "A" if shifted).
    `shifted` specifies whether to act as if the Shift key is pressed and
    defaults to `false`.

    An empty string is returned if the specified key is not associated with a
    character (a modifier key, for example).

Keyboard#clearQueue(); [API 1]

    Removes all keys from the keyboard queue.  If another key is not pressed
    in the interim, the next getKey() will return null.

Keyboard#getKey(); [API 1]

    Gets the next key in the keyboard queue, or null if the queue is empty.

Keyboard#isPressed(key); [API 1]

    Returns true if the user is currently pressing the specified key.  `key`
    should be a member of the Key enumeration.


`Mixer` Object
--------------

Mixers are used to group related audio together and adjust their parameters as
a class; this is useful, for example, for implementing global volume controls
in your game.

Mixer.Default [get] [API 1]

    Gets the default Audialis audio mixer.  The default mixer outputs 44.1 kHz
    16-bit stereo sound, i.e. CD quality.

new Mixer(frequency, bits[, channels]); [API 1]

    Constructs a new Mixer object.  Any sounds played through the mixer will use
    the format specified by the parameters above.  `frequency` is the sample
    rate, `bits` specifies the bit depth (allowed values are 8, 16 and 24), and
    `channels` is the number of channels, ranging [1-7].  Channel counts of 5 or
    higher imply an additional LFE channel (i.e. 5.1, 6.1, 7.1).

    Do note that this creates a _hardware_ mixer.  If the requested format is
    not supported by the system, an error will be thrown ("unable to create
    hardware voice").

Mixer#volume [get] [set] [API 1]

    Gets or sets the output volume of the mixer.  This will affect the volume
    of any sounds played through the mixer.


`Model` Object
--------------

A `Model` represents a group of shapes, combined with a shader and transforms,
which are drawn to a surface as a single unit.  Used well, this can improve
your game's rendering performance by grouping together operations using similar
parameters.

new Model(shapes[, shader]); [API 1]

    Constructs a Model out of the provided array of Shape objects.  `shader` is
    the Shader to use when rendering the model.  See below for more information
    on shaders.

    When a Model is created, its transformation matrix is set to the
    identity matrix.  If `shader` is not provided, the default shader program
    will be used (see `Shader.Default`).

Model#shader [get] [set] [API 1]

    Gets or sets the Shader to use when drawing this model.

Model#transform [get] [set] [API 1]

    Gets or sets the transformation matrix to use when drawing this model.

Model#draw([surface]); [API 1]

    Draws the model on `surface`, or the backbuffer if no surface is specified.
    Any transformations defined for the model (see below) are applied as if all
    the shapes comprising it were a single object.


`Mouse` Object
--------------

The `Mouse` object allows your game to accept input from a mouse, another
common input method for games.  As with the `Keyboard` object, `Mouse` provides
an event queue which accumulates clicks and other events until the game is
ready to process them.

MouseKey [enumeration] [API 1]

    Specifies a mouse click or other event (such as a wheel movement).  Can
    be one of the following:

        MouseKey.Left
        MouseKey.Middle
        MouseKey.Right
        MouseKey.WheelUp
        MouseKey.WheelDown

    The following values were added in API 2:

        MouseKey.Back
        MouseKey.Forward

Mouse.Default [get] [API 1]

    Gets a `Mouse` object for the default mouse device.

    Note: neoSphere currently only supports a single mouse.

Mouse#position [get] [API 3]

    Gets the immediate X and Y position of the mouse cursor relative to the
	game's rendering area.  This returns an array `[ x, y ]` which can be
	conveniently taken apart with destructuring assignment:

	    let [ mouseX, mouseY ] = mouse.position;

Mouse#x [get] [API 1]
Mouse#y [get] [API 1]

    Gets the immediate X and Y position of the mouse cursor relative to the
    game's rendering area.

Mouse#clearQueue(); [API 1]

    Removes all events from this mouse's event queue.  If another event is not
    received in the interim, the next getEvent() will return null.

Mouse#getEvent(); [API 1]

    Gets the next event in this mouse's event queue.  This returns an object
    with the following properties:

        event.key

            A MouseKey value representing the type of the click or other event.
            For example, a left mouse click is represented as MouseKey.Left.

            Note: If the queue was empty, this will be `null` and the remaining
                  properties will be undefined.

        event.x
        event.y

            The X and Y position of the mouse cursor relative to the rendering
            area at the time the event was received.

        event.delta [API 2]

            For mouse wheel events, specifies how much the wheel has moved.
            For any other event, this will be `undefined`.

    Note: Newer API revisions may include additional MouseKey values, so your
          game will eventually have to deal with key codes it can't recognize.
          To ensure forward compatibility, you must not treat this as an error;
          the event should simply be ignored.

Mouse#isPressed(key); [API 1]

    Gets whether the specified mouse button is currently pressed.  `key` is one
    of the MouseKey constants listed above.

    Note: This function always returns false for virtual keys such as WheelUp
          and WheelDown.


`RNG` Object
------------

Games often have need of a good psuedorandom number generator, particularly in
the case of RPGs.  JavaScript provides a barebones generator in the form of
`Math.random()`.  Sphere takes it one step further with the powerful `RNG`
object.

Sphere uses the xoroshiro128+ algorithm to generate high-quality random numbers
and allows manually seeding the generator, as well as saving and restoring the
exact state of the generator at any time.  RNG state is often saved along with
other save data as a way to deter save scumming.

RNG.fromSeed(seed); [API 1]

    Constructs a new random number generator seeded using the specified value.
    The specific sequence of numbers generated is entirely defined by the seed:
    Two generators running in parallel, initialized with the same seed, will
    always produce the same sequence.

    `seed` is a number greater than zero.  If the seed is fractional, only the
    integer part is used; everything after the decimal point is ignored.

RNG.fromState(state); [API 1]

    Constructs a new random number generator which starts in the specified
    state.  See RNG#state for more information.

new RNG(); [API 1]

    Constructs a new random number generator seeded from the current system
    time.

RNG#state [get] [set] [API 1]

    Gets or sets the current state of this generator.  State is encoded as
    a 32-digit hexadecimal string which makes it easy to save and restore.

    When setting `RNG#state`, the string given must be exactly 32 characters
    and consist only of hexadecimal digits (0-9, A-F), otherwise a TypeError
    will be thrown.

RNG#next(); [API 1]

    Generates the next random number in the sequence.  This returns an object
    whose `done` property is always false, and whose `value` property is a
    number in the range [0, 1).

    Note: This method is compatible with the JavaScript ES6 iterator protocol,
          allowing you to use the RNG object as input to a `from()` query.
          Refer to the Sphere Runtime API documentation for more information
          about `from()`.


`SSj` Namespace
---------------

The `SSj` namespace provides functions that aid debugging and allow your game
to communicate with an attached debugger such as SSj or SSj Blue.  Note that
`SSj` methods only have an effect when called under SpheRun; in production they
do nothing.

SSj.assert(condition[, description]);

    Checks that some condition is true and throws an error if it's not.  This
    allows you to test assumptions made during development without compromising
    performance in production.  `condition` can be either a boolean expression
    or a function that returns `true` or `false`.

    `description` is an optional text description of the condition under test.
    This should describe what's being checked for, as the error thrown in case
    of failure is "Assertion was false: <description>".

    Note: Use a function for `condition` if you need to do a complicated sanity
          check; this way the engine can avoid running the check at all in
          production.

SSj.flipScreen();

    Immediately flips the contents of the backbuffer to the screen.  The
    backbuffer is not cleared afterwards.  Useful for debugging graphics code.

SSj.log(text_or_object);

    Logs `text_or_object` to an attached SSj or SSj Blue session.  If an object
    is passed in, logs the result of calling `JSON.stringify()` on the object.

    Note: If the game was started from the command line using SpheRun, the
          item is logged to the terminal as well.

SSj.now();

    Returns the time in seconds since some arbitrary point in time, accurate to
    the microsecond.  Useful for measuring performance.  In production, this
    always returns 0.0; use `Date.now()` for in-game timing purposes.

SSj.profile(object, method_name[, description]);

    Adds a method to be automatically profiled (timed) by SpheRun.
    `description` is an optional string to name the function in the performance
    report; if no description is given, the engine will use the name of the
    function.

    `object` is the object whose method is being profiled, and `method_name` is
    the name of the method.  Note that to profile a method for all instances of
    a class, you can specify the prototype.  For example, to profile all calls
    to `Font#drawText()`:

        SSj.profile(Font.prototype, 'drawText');

    Note: SpheRun must be started with the `--performance` option to enable the
          profiler.  All `SSj.profile()` calls will be completely ignored if
          the profiler is not enabled.

SSj.trace(text);

    Logs `text` to an attached SSj or SSj Blue session.  This is intended for
    low-level, detailed logging; by default, traces will not be displayed, even
    in the debugger, unless enabled by the user.


`Sample` Object
---------------

A `Sample` represents a sound effect.  Multiple instances of a sample can be
played simultaneously, on any mixer.  Unlike a `Sound` object, the audio data
for a `Sample` is loaded into memory in its entirety and multiple instances can
be played simultaneously with no latency, making this very useful for sound
effects.

Sample.fromFile(filename); [async] [API 3]

    Loads the audio file named by `filename` asynchronously and returns a
    promise for the newly constructed Sample object.  Supported formats are
    Ogg Vorbis (.ogg), WAV, and FLAC.

    Note: Compressed formats like Vorbis will be decompressed during loading,
          potentially using a large amount of RAM.  It is therefore not
          recommended to use `Sample` objects for, e.g., background music.  Use
          a `Sound` instead.

new Sample(filename); [API 1]

    Loads an audio file named by `filename` and returns a new `Sample` object
    created from it.

    Note: This call is not supported when targeting API 4 or higher. Use
          `Sample.fromFile()` instead.

Sample#fileName [get] [API 1]

    Gets the full SphereFS pathname of the audio file used to construct this
    Sample object.

Sample#play(mixer[, options]); [API 1]

    Plays the sample on the specified mixer.  Each time this is called, a new
    stream is started, allowing many instances of the sound to be playing
    simultaneously.

    `options`, if present, must be an object and can include the following
    properties (all optional):

        options.volume

            The volume level to play the sound at.  1.0 is full volume, 0.0 is
            silent.  Volume levels higher than 1.0 will amplify the sound but
            may cause distortion.  Volume is 1.0 if not specified.

        options.pan

            A volume between -1.0 and 1.0 specifying the left/right balance.
            -1.0 is full left, +1.0 is full right, and 0.0 is dead center.  Pan
            is 0.0 (center) if not specified.

        options.speed

            Playback speed, where 1.0 is normal speed.  Also affects pitch.
            Speed is 1.0x if not specified.

Sample#stopAll(); [API 1]

    Stops playback of all active instances of this sample.


`Server` Object
---------------

A `Server` represents a basic TCP server which listens for connections on a
specified port.  Clients connecting to the server are placed in a backlog and
must be explicitly accepted by game code.

new Server(port[, backlog_size]); [API 1]

    Constructs a new server to listen for connections on the specified port.
    `backlog_size` specifies the size of the backlog and defaults to 128.  If
    the backlog fills, new connections will be refused.

Server#noDelay [get] [set] [API 2]

    Gets or sets a boolean value indicating whether Nagle's algorithm is turned
    off for this server.  This doesn't directly affect the server but will be
    used as the initial setting of `noDelay` for all sockets returned by
    `accept()` or `acceptNext()`.

Server#numPending [get] [API 2]

    Gets the number of pending connections currently in the backlog.  If the
    number of pending connections is allowed to reach the backlog size
    specified at `Server` construction, new connections will be refused.

Server#accept(); [API 1]

    Returns a Socket for the next connection in the backlog.  If the backlog is
    empty, a RangeError will be thrown, so you should check the value of
    `numPending` first to see if there are any connections in the backlog.

Server#acceptNext(); [async] [experimental]

    Instructs Sphere to accept the next available client connection via the
    event loop.  The promise resolves with a Socket representing that
    connection.  This is an asychronous version of `accept()` that can be used
    with `await`.

Server#close(); [API 1]

    Shuts down the server.  The server port will be closed and any connections
    already in the backlog will be dropped.


`Shader` Object
---------------

A `Shader` is a program that runs on the system's graphics processor and
manipulates vertices and pixels as they are rendered to a surface.  Shaders are
written in the GLSL shader programming language, which is beyond the scope of
this document.

Shader.Default [get] [API 1]

    Gets the default Galileo shader program.  This is a very barebones shader
    that performs only basic transformations and texture mapping.

Shader.fromFiles(options); [async] [API 3]

    Loads the shader source files specified in `options` asynchronously and
    returns a promise for the newly constructed Shader object.

    options.vertexFile [required]

        The name of a file containing GLSL source code for the program's vertex
        shader.

    options.fragmentFile [required]

        The name of a file containing GLSL source code for the program's
        fragment shader.

new Shader(options); [API 1]

    Loads the shader source files specified in `options` (refer to the
    documentation of `Shader.fromFiles` above) synchronously, without yielding
    to the event loop, and returns the newly constructed Shader object.  May
    not be supported on all platforms.

    Note: This call is not supported when targeting API 4 or higher. Use
          `Shader.fromFiles()` instead.

Shader#clone(); [API 1]

    Creates a copy of this shader.  The new shader is distinct from the first
    and can have its own independent uniform values.  As uniform values are
    persistent, cloning a shader can sometimes be useful as an optimization.

    Note: Uniform values are not copied; the cloned shader will be constructed
          with all of its uniforms set to their default values.

Shader#setBoolean(name, value); [API 1]

    Sets the value of a GLSL boolean-valued (`bool`) uniform.  `value` is
    either `true` or `false`.

Shader#setColorVector(name, color); [API 1]

    Sets the value of a GLSL floating point 4-vector uniform (`vec4`) from the
    components of a `Color` object.  Order is assumed to be RGBA.

Shader#setFloat(name, value); [API 1]
Shader#setInt(name, value); [API 1]

    Sets the value of a GLSL scalar uniform.

    Note: Only `float` and `int` types are currently supported.

Shader#setFloatArray(name, values); [API 1]
Shader#setIntArray(name, values); [API 1]

    Sets the values of a GLSL array uniform.  `values` should be an array
    containing a number of values equal to the size of the array, otherwise
    the uniform will not be set.

    Note: Only `float` and `int` types are currently supported.

Shader#setFloatVector(name, values); [API 1]
Shader#setIntVector(name, values); [API 1]

    Sets the value of a GLSL vector uniform.  `values` must be an array and
    contain between 2 and 4 values, inclusive.  If not, an error will be
    thrown.

    Note: Only `vecN` (float) and `ivecN` (integer) types are currently
          supported.

Shader#setMatrix(name, transform); [API 1]

    Sets the value of 4x4 matrix uniform (`mat4`) using the underlying matrix
    cells of a `Transform` object.

    Note: Matrix types other than `mat4` are not currently supported.

Shader#setSampler(name, texture, texture_unit); [experimental]

    Assigns a texture to a texture unit.

    Note: Texture unit 0 is reserved for use by Sphere, typically accessed in
          shaders via `al_tex`.


`Shape` Object
--------------

A `Shape` represents a group of textured triangles, line segments, or points to
be drawn to a surface.  Shapes can be drawn directly, or added to a `Model` to
group related rendering operations together.

ShapeType [enumeration] [API 1]

    Specifies the type of graphics primitive represented by a Shape object.
    Can be one of the following:

        ShapeType.Fan
        ShapeType.Lines
        ShapeType.LineLoop
        ShapeType.LineStrip
        ShapeType.Points
        ShapeType.Triangles
        ShapeType.TriStrip

Shape.drawImmediate([surface, ]type[, texture], vertices); [API 2]

    Draws a shape to a surface in immediate mode (on-the-fly).  Useful when
    you need to create shapes on demand (procedural generation, for instance)
    without incurring the expense of creating Shape and VertexList objects
    every frame.

    `type` should be one of the ShapeType constants above and `vertices` is an
    array in the same format as for `new VertexList()` (see below).  `texture`
    can be either a Texture or Surface object.

    Note: `.drawImmediate()` is significantly slower than drawing pre-made
          Shapes.  Keep this in mind when writing your rendering code as
          immediate-mode rendering can very easily become a performance issue.

new Shape(type[, texture], vertexList[, indexList]); [API 1]

    Constructs a primitive shape from a vertex list and optional index list,
    textured with a specified `Texture` image.  `type` specifies the type of
    primitive to draw (see `ShapeType` above).

    `vertexList` is a `VertexList` containing vertices for the shape, while
    `indexList`, if provided, is an `IndexList` specifying which vertices from
    the vertex list will comprise the shape.  If `indexList` is not specified,
    all vertices from `vertexList` will be used.

Shape#indexList [get] [set] [API 1]

    Gets or sets the index list used to select vertices for this shape.  Set
    this to `null` to use the entire vertex list.

Shape#texture [get] [set] [API 1]

    The Image to use when texturing the shape. This can be null, in which case
    the vertex colors alone will determine the shape's appearance.

Shape#vertexList [get] [set] [API 1]

    Gets or sets the vertex list containing vertices for this shape.

Shape#draw([surface[, transform]]); [API 1]

    Draws the shape onto `surface`, or the backbuffer if no surface is
    specified.  `transform` is the Transform to use.

    Note: If the shape's current index list is larger than its vertex list, a
          RangeError will be thrown.


`Socket` Object
--------------

A `Socket` represents a raw TCP connection to another computer.  Sockets can
either be created manually for outgoing connections, or returned by
`Server#accept()` (or `acceptNext()`) to represent an incoming connection.

Sphere Sockets are non-blocking, fully buffered, and reusable.  Network
communication is handled in the event loop so that `read()` and `write()` calls
return immediately; data is buffered which allows the game to read or write at
at any time with no rate limit; and if a connection is lost, the socket can be
reconnected by simply calling its `connectTo()` method again.

Socket.for(hostname, port); [async] [API 3]

    Connects to the specified host and port and returns a promise for a newly
    constructed Socket object for the connection.  If the connection attempt
    fails, the promise is rejected.

new Socket([hostname, port]); [API 1]

    Constructs a new socket object.  If `hostname` and `port` are specified,
    Sphere will immediately attempt to connect the socket; otherwise, it will
    be created in a disconnected state and you must call `connectTo()` manually
    to connect it.

Socket#bytesAvailable [get] [API 1]

    Gets the number of bytes of data currently in this socket's receive buffer.
    This is the maximum amount of data you can retrieve using `read()` on the
    current frame without it throwing a RangeError.

Socket#bytesPending [get] [API 1]

    Gets the number of bytes of data currently in this socket's write-behind
    buffer.  This is the amount of data which has been written to the socket
    but not yet sent over the network.

    Accessing this property on a disconnected socket will throw a TypeError.

Socket#bytesReceived [get] [API 2]

    Gets the total number of bytes of data received through this socket since
    it was last connected, including data still in the socket's receive buffer
    and not yet read by the game.

Socket#bytesSent [get] [API 2]

    Gets the total number of bytes of data transmitted through this socket
    since it was last connected.

    Note: This only counts bytes actually sent over the network.  Data still
          waiting in the socket's write-behind buffer is not counted.

Socket#connected [get] [API 1]

    Gets whether the connection has been established.  As long as this is
    false, you won't be able to call most methods (except `connectTo`) on the
    socket object.

Socket#noDelay [get] [set] [API 2]

    Gets or sets a boolean value indicating whether Nagle's algorithm is turned
    off for this socket.  If `false` (the default), the operating system may
    delay transmission of small writes while waiting on acknowledgement of a
    previous transmission.

Socket#remoteAddress [get] [API 1]

    Gets the IP address of the upstream end of the socket.  If the socket is
    disconnected, accessing this will throw an error.

Socket#remotePort [get] [API 1]

    Gets the port that the remote machine is using for its side of the
    connection.  Generally not very useful, but it's there if you need it.  If
    the socket is disconnected, accessing this will throw an error.

Socket#asyncRead(num_bytes); [async] [API 3]

    Instructs Sphere to read `num_bytes` from the socket via the event loop.
    The promise resolves with an ArrayBuffer containing the data read.  This is
    an asynchronous version of `read()` that can be used with `await`.

    Note: This call will not fail if there is not enough data in the receive
          buffer to immediately satisfy it.  However, if the connection is lost
          before the read completes, Sphere will reject the promise.

Socket#asyncWrite(data); [async] [API 3]

    Instructs Sphere to write `data`--either an ArrayBuffer, TypedArray view,
    or DataView--to the socket via the event loop.  The promise resolves once
    all bytes have been transmitted.  This is an asynchronous version of
    `write()` that can be used with `await`.

    Note: If the connection is lost before the write completes, Sphere will
          reject the promise.

Socket#close(); [async] [API 1]

    Disconnects the socket.  Data remaining the socket's write-behind buffer
    will be written out before the connection is closed.  The promise resolves
    once the socket is no longer connected.

Socket#connectTo(hostname, port); [async] [API 1]

    Connects the socket to `hostname` on `port`.  `hostname` can either be a
    domain name (e.g. google.com) or IP address (e.g. 127.0.0.1).  The promise
    resolves when the socket is ready for communication.  If there is still
    data in the socket's receive buffer at this time, it will be discarded.

    Note: A single socket can only be connected to one client at a time.  If
          the socket is already connected when `connectTo()` is called, a
          TypeError will be thrown.

Socket#disconnect(); [API 2]

    Immediately disconnects the socket.  If there is still data in the socket's
    write-behind buffer that hasn't been transmitted, it will be discarded.

Socket#peek(num_bytes); [API 2]

    Peeks at the next `num_bytes` from the socket's receive buffer and returns
    an ArrayBuffer containing the data found there.  The data is not removed
    from the receive buffer and will be returned in subsequent read(s).

Socket#read(num_bytes); [API 1]

    Reads `num_bytes` bytes from the socket's receive buffer and returns an
    ArrayBuffer containing the data received.

    This call is non-blocking; if there is not enough data in the socket's
    receive buffer to satisfy the read, a RangeError will be thrown.  To avoid
    the RangeError, check the value of `bytesAvailable` first.

Socket#write(data); [API 1]

    Writes data to the socket, to be read on the other end.  `data` can be an
    ArrayBuffer, TypedArray view, or DataView.  This function always returns
    immediately; Sphere will transmit the data from the event loop as soon as
    it's possible to do so.

    Note: No error is produced if the connection is lost mid-transmission.  If
          you need to detect this, you can either monitor the value of
          `bytesSent`, or else just call `asyncWrite()` which will reject its
          promise if an early disconnection happens.


`Sound` Object
--------------

A `Sound` represents a streaming audio file.  Because the sound is streamed, it
remains compressed, saving RAM; however, only one instance of the sound can be
played at a time.

Sound.fromFile(filename); [async] [API 3]

    Loads the audio file named by `filename` asynchronously and returns a
    promise for the newly constructed `Sound` object.  Supported sound formats
    are mp3, Ogg Vorbis (.ogg), WAV, MOD, S3M, IT, and FLAC.

new Sound(filename); [API 1]

    Loads the audio file named by `filename` and returns the newly constructed
    `Sound` object.

    Note: This call is not supported when targeting API 4 or higher. Use
          `Sound.fromFile()` instead.

Sound#fileName [get] [API 1]

    Gets the full SphereFS pathname of the file used to construct this Sound
    object.

Sound#length [get] [API 1]

    Gets the length of the sound in microseconds.

Sound#pan [get] [set] [API 1]

    Gets or sets the current pan (balance). 0.0 is dead center, -1.0 is full
    left, and 1.0 is full right.

Sound#playing [get] [API 1]

    true if the sound is currently playing, false otherwise.

Sound#position [get] [set] [API 1]

    Gets or sets the playback position within the sound, in seconds.

Sound#repeat [get] [set] [API 1]

    Gets or sets whether the sound will automatically repeat when it reaches
    the end.

Sound#speed [get] [set] [API 1]

    Gets the current playback speed of the sound.  1.0 is normal, 2.0 is double
    speed, etc.  Note that changing the playback speed affects the pitch as
    well.

Sound#volume [get] [set] [API 1]

    Gets or sets the current volume of the sound.  0.0 is silent, 1.0 is full
    volume.  Higher values are allowed, but may introduce distortion due to
    clipping.

Sound#pause(); [API 1]

    Pauses the sound.  If it is already paused, this has no effect.

Sound#play([mixer]); [API 1]

    Begins or resumes sound playback.  When called with no `mixer` argument,
    Sound#play() will resume playback for a paused sound.  Otherwise, the sound
    is started from the beginning on the specified mixer.

Sound#stop(); [API 1]

    Stops the sound.  Playback position will be reset to the beginning (0.0s),
    even if the sound was not playing.


`SoundStream` Object
--------------------

A `SoundStream` represents a dynamic audio stream which can be used to play
arbitrary audio data, fed to the stream by your game in realtime.  This can be
used to implement procedural audio, for example.

new SoundStream([frequency[, bits[, channels]]]); [API 1]

    Constructs an audio stream, which plays arbitrary sound data provided by
    the game at runtime.  This may be used, for example, to generate sound
    procedurally or add support for an unsupported audio format in script.
    `frequency` specifies the stream's sample rate and 'channels' the number of
    audio channels, ranging [1-7].  Channel counts of 5 and higher imply an
    additional LFE (subwoofer) channel.

    The default stream format is 8-bit 22050Hz with 1 channel.

SoundStream#length [get] [API 1]

    Gets the amount of audio currently buffered into the stream, in seconds.
    Playback will pause if the buffer is exhausted; To ensure skip-free
    playback, you should monitor the stream and write more data before `length`
    reaches zero.

SoundStream#pause(); [API 1]

    Pauses playback of the stream.  Has no effect if the stream is already
    paused.

SoundStream#play([mixer]); [API 1]

    Starts the stream playing, or if no mixer is specified, resumes a paused
    stream.  Before beginning playback, it is recommended to pre-buffer a few
    seconds of audio into the stream (see SoundStream#write() below).  This
    will minimize the risk of a buffer underrun and subsequent skipping during
    playback.

SoundStream#stop(); [API 1]

    Stops playback of the stream and frees its buffer.  This should be called
    when you are done using a stream.  The stream may be reused after a stop()
    call, but you will have to feed new audio data.

SoundStream#write(data); [API 1]

    Writes audio data to the stream buffer.  `data` is an ArrayBuffer,
    TypedArray or DataView containing the data to write.  While a stream is
    playing, audio data should be fed into it continuously to prevent skipping.


`Surface` Object
----------------

The `Surface` object represents a rendering target.  Your game doesn't always
need to draw directly to the screen; it sometimes makes sense to compose
complex parts of a scene in advance, offscreen, so that you don't have to
redraw them every frame.  A Surface object can be used anywhere a texture is
expected.  This avoids the need to make a copy of the surface and additionally
enables render-to-texture effects to be implemented.

Note: Surfaces can only be used as textures under API level 2 or higher.  When
      targeting API level 1 you must call `.toTexture()` (see below) first.

Surface.Screen [get] [API 1]

    A special Surface object representing the backbuffer.  Anything drawn to
    this surface will automatically become visible on the screen the next time
    the event loop regains control.

Surface.fromFile(filename); [async] [API 3]

    Loads the image file named by `filename` asynchronously and returns a
    promise for a Surface whose dimensions and initial content match that of
    the loaded image.

new Surface(width, height[, content]); [API 1]

    Constructs a new Surface with the specified content.  `width` and `height`
    specify the size in pixels of the surface, and `content` is either a
    `Color` (in which case the surface will be filled with that color) or a
    buffer object holding the RGBA pixel data to use to initialize the image.
    The pixel data should not be padded (i.e. stride equal to width).

    If `content` is not specified, the surface will be filled with transparent
    pixels (`Color.Transparent`).

    Note: When passing a buffer for `content` and the buffer doesn't contain
          enough pixel data to cover the entire surface, a RangeError will be
          thrown.

new Surface(filename); [API 1]

    Loads the image file named by `filename` synchronously, without yielding to
    the event loop, and returns a Surface whose dimensions and initial content
    match that of the loaded image.  May not be supported on all platforms.

    Note: This call is not supported when targeting API 4 or higher. Use
          `Surface.fromFile()` instead.

Surface#blendOp [get] [set] [API 2]

    Gets or sets the blending operation (see `BlendOp` above) for objects drawn
    to this surface.

Surface#depthOp [get] [set] [experimental]

    Gets or sets the depth test criteria for 3D objects drawn to this surface.
    The final Z coordinate of each pixel drawn is tested against the current
    value in the surface's depth buffer and is either rendered or skipped based
    on the operation specified:

        DepthOp.AlwaysPass
        DepthOp.NeverPass
        DepthOp.Equal
        DepthOp.Greater
        DepthOp.GreaterOrEqual
        DepthOp.Less
        DepthOp.LessOrEqual
        DepthOp.NotEqual

	The default for new surfaces is `AlwaysPass`.

Surface#transform [get] [set] [API 1]

    Gets or sets a `Transform` representing the surface's projection matrix.
    When rendering is done on the surface, the projection matrix is the last
    one applied and affects the entire scene.

    Note: The default projection matrix in Sphere is NOT an identity matrix.
          When a surface is created, Sphere sets its transform to an
          orthographic matrix suitable for pixel-perfect 2D rendering.

Surface#width [get] [API 1]
Surface#height [get] [API 1]

    Gets the width and height of the surface, in pixels.  For the screen, this
    is the game's nominal resolution, i.e. the resolution it renders at.

Surface#clear([color[, depthValue]]); [experimental]

    Clears the entire surface using the specified color and depth value (depth
    is automatically clamped between 0.0 and 1.0).  If not provided, `color`
    defaults to `Color.Transparent` and `depthValue` to 1.0.

    Note: The backbuffer (`Surface.Screen`) is automatically cleared at the
          beginning of each frame.

Surface#clipTo(x, y, width, height); [API 1]

    Sets the surface's clipping rectangle.  Values are expressed in pixels.
    Anything drawn outside of the clipping rectangle won't be rendered.

    Note: When setting the clipping rectangle for the screen, the effect only
          lasts until the next frame.

Surface#toTexture(); [API 1]

    Returns a Texture created from the current contents of this Surface.  Note
    that drawing to the surface afterwards will not affect the texture, which
    is read-only.

    Note: It is not necessary to call this when targeting API level 2 or later;
          as noted above, the surface itself can be used as a texture.


`Texture` Object
----------------

A `Texture` is an image which can used to as a texture for shapes drawn using
the Sphere v2 graphics API.  Unlike in Sphere v1, you cannot draw an image
directly using the Core API; it must be used to texture a `Shape`.

Note that Textures are read-only.  If you need a writable texture, you can use
a Surface object instead.

Texture.fromFile(filename); [async] [API 3]

    Loads the image file named by `filename` asynchronously and returns a
    promise for a new `Texture` object.  Supported formats are BMP, PNG, and
    JPG.

new Texture(filename); [API 1]

    Loads the image file named by `filename` and immediately returns a texture
    containing that image.

    Note: This call is not supported when targeting API 4 or higher. Use
          `Texture.fromFile()` instead.

new Texture(width, height[, content]); [API 1]

    Constructs a new Texture with the specified content.  `width` and `height`
    specify the size in pixels of the texture, and `content` is either a
    `Color` (in which case the texture will be filled with that color) or a
    buffer object holding the RGBA pixel data to use to initialize the image.
    The pixel data should not be padded (i.e. stride equal to width).

    If `content` is not specified, the texture will be filled with transparent
    pixels (`Color.Transparent`).

    Note: When passing a buffer for `content` and the buffer doesn't contain
          enough pixel data to cover the entire texture, a RangeError will be
          thrown.

new Texture(surface); [API 1]

    Constructs a new Texture from the contents of `surface`, a Surface object.
    Subsequent modifications to the surface will not affect the contents of the
    new texture.

Texture#fileName [get] [API 1]

    Gets the full SphereFS pathname of the file used to construct this Texture
    object.  For synthesized textures, e.g. those created from a surface, this
    is `null`.

Texture#width [get] [API 1]
Texture#height [get] [API 1]

    Gets the width or height of the texture, in pixels. Throws an error if the
    texture isn't ready for use yet.

Texture#download(); [experimental]

    Downloads the 32-bit RGBA pixel data from the texture and returns it as a
    new Uint8ClampedArray.

    Note: Downloading data from the GPU is a rather slow operation and
          shouldn't be done at render time if you can avoid it.  Use a Surface
          for render-to-texture effects if at all possible.

Texture#upload(content); [experimental]

    Uploads 32-bit RGBA pixel data from `content` (an ArrayBuffer or typed
    array) to the texture.  Enough data must be provided to completely rewrite
    the texture or a RangeError will be thrown.


`Transform` Object
------------------

A `Transform` represents a transformation matrix used to convert vertex
coordinates for shapes drawn to a surface.

Transform.Identity [get] [experimental]

    Gets the identity transformation matrix.  This transformation simply uses
    vertex values as is, without modifying them in any way.

Transform.project2D(left, top, right, bottom[, near, far]); [experimental]

    Returns an orthographic projection transform used for rendering in 2D.  For
    pixel-perfect rendering, set `left` and `top` to 0 and `right` and `bottom`
    to the pixel size of the surface being drawn to.  This is the default
    projection transform for all new surfaces, including `Surface.Screen`.

    `near` and `far` are distances relative to the front of the "camera" beyond
	which objects will not be visible.  If not provided, `near` defaults to
	-1.0 and `far` defaults to 1.0.

Transform.project3D(fov, aspect_ratio, near, far); [experimental]

    Returns a perspective transform that projects a scene into 3D.  `fov` is
    the extent of the camera's field of view, in degrees.  `aspect` is the
    aspect ratio of the scene, and to avoid distortion should usually match the
    aspect ratio of the surface being projected onto.

    `near` and `far` define the distances in front of the camera beyond which
    objects will not be visible.  For 3D projections, these must be nonzero and
    positive, or an error will be thrown.

Transform.rotate(angle[, vx, vy, vz]); [experimental]

    Returns a transform which can be used to rotate an object or scene about an
    arbitrary axis.  `angle` is the amount of rotation to apply, in degrees.
    (vx, vy, vz) is the vector to be rotated around.  For example, the default
    is (0, 0, 1) which produces a rotation about the Z (depth) axis.

Transform.scale(sx, sy[, sz]); [experimental]

    Returns a transform which scales all vertex coordinates by a given amount.
    `sx`, `sy`, and `sz` are the scaling factors for each coordinate.  If `sz`
    is not provided, it defaults to 1.0, which leaves the Z coordinate
    unchanged.

Transform.translate(tx, ty[, tz]); [experimental]

    Returns a transform which translates (moves) all vertex coordinates by a
    given distance.  `tx`, `ty`, and `tz` are the distances to move along each
    axis.  If `tz` is not provided, it defaults to 0.0, which leaves the Z
    coordinate unchanged.

new Transform(); [API 1]

    Constructs a transformation matrix.  The object represents a 4x4 matrix
    and is initialized to `Transform.Identity`.

Transform#matrix [get]

    Gets an object you can use to access the cells of the underlying matrix.
    The object is used like a two-dimensional array:

        cellValue = transform_obj.matrix[i][j];
        transform_obj.matrix[i][j] = newValue;

Transform#identity(); [API 1]

    Resets this transform's underlying matrix to the identity matrix.

Transform#compose(otherMatrix); [API 1]

    Composes this transform with another.  `otherMatrix` is multiplied from the
    left such that transformations are performed in the order you specify.

Transform#project2D(left, top, right, bottom[, near, far]); [API 1]

    Adds a 2D orthographic projection to this transform.  This is equivalent to
    calling `compose()` with the transform returned by `Transform.project2D()`.

Transform#project3D(fov, aspect, near, far); [API 1]

    Adds a 3D perspective projection to this transform.  This is equivalent to
    calling `compose()` with the transform returned by `Transform.project3D()`.

Transform#rotate(angle[, vx, vy, vz]); [API 1]

    Adds a rotation to this transform.  This is equivalent to calling
    `compose()` with the transform returned by `Transform.rotate()`.

Transform#scale(sx, sy[, sz]); [API 1]

    Adds a scaling transformation to this transform.  This is equivalent to
    calling `compose()` with the transform returned by `Transform.scale()`.

Transform#translate(tx, ty[, tz]); [API 1]

    Adds a translation to this transform.  This is equivalent to calling
    `compose()` with the transform returned by `Transform.translate()`.


`VertexList` Object
-------------------

A `VertexList` contains a collection of vertices for use when constructing a
`Shape`.  The vertices in the vertex list are stored on the GPU for fast access
at render time.

new VertexList(vertices); [API 1]

    Constructs a new vertex list from `vertices`, an array of objects with the
    following properties:

        vertex.x, vertex.y

            The location of the vertex.  The final location of each vertex can
            be modified by using a transformation matrix (see Matrix above).

        vertex.u, vertex.v

            The texture coordinates of the vertex.  This is used to control
            which part of the texture will be applied to this vertex.  If u/v
            is not provided for a vertex, it will be assumed to be have its u/v
            at (0, 0).

        vertex.color

            The color of the vertex.  The vertex colors will be multiplied with
            texture pixels to determine the final color of each pixel in a
            shape.

    If `vertices` is not an array or any element is not a valid object as
    described above, an error will be thrown.

    Note: The list of vertices stored on the GPU can't be modified later.  If
          you want to upload a new set of vertices, you must construct a new
          `VertexList`.


`Z` Namespace
-------------

The somewhat cryptically-named `Z` namespace hosts functions used for data
compression.

Z.deflate(data[, level]); [experimental]

    Compresses the data in an ArrayBuffer or TypedArray using the DEFLATE
    compression method.  `level` specifies the compression level from
    0 (no compression) to 9 (maximum), with 7 being the default.  Returns an
    ArrayBuffer containing the compressed data.

Z.inflate(data[, max_size]); [experimental]

    Decompresses data in an ArrayBuffer or TypedArray which was previously
    compressed using DEFLATE.  `max_size` is optional and specifies an upper
    limit on the size of the decompressed data, useful for preventing
    "zip bomb" attacks.  Returns an ArrayBuffer containing the decompressed
    data.
